<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript中的LHS和RHS]]></title>
      <url>%2F2017%2F02%2F21%2FJavaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%2F</url>
      <content type="text"><![CDATA[前言本文主要对JavaScript中的LHS和RHS进行解释介绍，并进行相应的举例说明。 LHS &amp; RHS概念分析 LHS与RHS是JavaScript引擎的两种查找类型，含义是赋值操作的左侧与右侧。 LHS(Left Hand Side)：对哪个赋值就对哪个进行LHS引用，可以理解为赋值操作的目标。 RHS(Right Hand Side)：需要获取哪个变量的值，就对哪个变量的值进行RHS引用，理解为赋值操作的源头。 可以简单的记忆为：一般在左边的需要被赋值，就是LHS引用；右边需要寻找到它的值，就是RHS引用。12345function foo(a)&#123; var b=a; rerurn a+b;&#125;var c=foo(2); 以上代码中有3个LHS与4个RHS，分析如下： var c中的c需要被赋值，在赋值操作的左侧，所以对c进行LHS引用 变量c需要被赋值，它的值是foo(2)，那么foo(2)的值是多少呢，需要查找foo(2)的值，在赋值操作的右侧，所以对foo(2)进行RHS引用 隐含赋值操作，将2传递给function foo(a){……}函数的参数a，a在赋值操作的左侧，对a进行LHS引用 var b=a;中，b需要被赋值，处在赋值操作的左侧，所以b进行的LHS，b的值将从a来，那么右侧的a的值从何而来呢？这就需要对赋值操作右侧的a进行RHS return a+b;中，需要找到a与b的值的来源，a与b都在赋值操作的右侧，才能得到a+b的值，所以对a与b都是进行RHS引用1.2 异常解释之所以区分LHS和RHS，只因为在遍历还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。 LHS和RHS查询都会在当前执行作用域中开始，如果有需要（即没有在当前作用域中查找到所需的标识符），就会向上级作用域继续查找目标标识符，直至抵达全局作用域，查找停止。 不成功的RHS引用会导致ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。 ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或者不合理的。查询到变量之后（已经表明作用域判别成功，不会出现ReferenceError异常），对这个变量进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用null或undefined类型值中的属性，那么引擎会抛出TypeError异常。 ES5中引入了“严格模式”。同正常模式（或称为宽松/懒惰模式相比），严格模式在行为上有很多不同，其中一个不同的行为则是严格模式禁止自动或隐式创建全局变量。因此，严格模式下，LHS查找失败后，不会自动隐式创建全局变量，只会抛出ReferenceError异常。 代码1 12345function foo(a)&#123; console.log(a+b); // b- RHS, a- RHS b = a; // b- LHS, a- RHS&#125;foo(2); 第一次对b进行RHS查询时，无法找到该变量，在其上级作用域（全局作用域）中依旧无法找到变量b，因此，引擎将抛出 ReferenceError异常。 若将代码1修改，在全局作用域中声明变量b，则在函数foo作用中对b进行RHS查找失败后，会自动向上一级的全局作用域中查找变量b。查找成功后，程序正常输出：12。123456function foo(a)&#123; console.log(a+b); // b- RHS, a- RHS b = a; // b- LHS, a- RHS&#125;var b = 10;foo(2); // 输出 12 若将上述代码再次修改，在全局作用域中声明变量b，并在局部作用域中声明变量b，则在函数foo作用中，使用局部变量b=3。全局作用域中，使用局部变量b=10。这种现象称为“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。123456789function foo(a)&#123; var b = 3; console.log(a+b); // b- RHS, a- RHS 输出：5 b = a; // b- LHS, a- RHS console.log("Global Scope: "+b); //2&#125;var b = 10;console.log("Global Scope: "+b); // 10foo(2); // 输出 12 代码212345function init(a)&#123; b = a + 3; &#125;init(2); console.log(b); //5 上述代码中，对b进行LHS。局部作用中查找变量b失败后，转向全局变量中查找变量b，依旧失败后，由于是LHS查询，因此会自动隐式创建一个全局变量b（这点与RHS不同）。因此，上述代码可以正常运行，并输出：5。 若将代码2修改，在局部作用域中声明变量b，则在全局作用域中执行console.log(b);,由于全局作用域中未声明变量b，因此将给出ReferenceError异常：ReferenceError: b is not defined.12345function init(a)&#123; var b = a + 3; &#125;init(2); console.log(b); //5 则在函数foo作用中对b进行RHS查找失败后，会自动向上一级的全局作用域中查找变量b。查找成功后，程序正常输出：12。 参考[1] javascript中的LHS与RHS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于AngularJS的抽奖系统练习总结]]></title>
      <url>%2F2017%2F01%2F23%2F%E5%9F%BA%E4%BA%8EAngularJS%E7%9A%84%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作基于AngularJS的抽奖系统demo过程中的一些心得和技巧。抽奖系统应用很广泛，基于AngularJS的抽奖系统具有代码清晰简洁，较高的执行效率和较强的扩展性等优势。这个抽奖系统主要包括以下一些效果及功能： 可以点击开始按钮进行抽奖 抽奖过程具有闪烁效果，在所有奖品上循环一定次数之后自动随机选择出中奖奖品，并显示在页面上。 结束抽奖之后，可以选择重新开始抽奖，还可以选择对奖品进行修改，包括对已有商品的删除和增加奖品等。 心得与技巧整体设计思路基于AngularJS框架，只需一个单页即可完成所需功能与要求。主要分为四个页面元素： 抽奖开始的初始化页面元素 抽奖过程中闪烁选择的页面元素 抽中奖品时显示奖品的页面元素 增加或删除奖品的页面元素 而这四个页面元素的切换可以通过放在不同的div容器中，然后通过控制容器的隐藏和显示来切换相应的页面元素。在这四个页面元素中，再分别初始化控制器数据，定义抽奖、中奖和修改奖品的方法等。值得一提的是，抽奖时奖品元素动态闪烁可以利用$timeout对象的注入来实现，而奖品信息也可以通过JSON格式来进行储存。 视图层的实现分析首先，在html标签上通过ng-app属性绑定页面模板名称，用于告诉 AngularJS 应用当前这个元素是根元素： 1&lt;html ng-app="lottery"&gt; 然后要记得用script标签引入angularjs的js文件： 1&lt;script src="lib/angular.min.js"&gt;&lt;/script&gt; 在body元素里，需要通过ng-controller属性定义控制器的作用域： 123&lt;div id="lottery" ng-controller="ctrl_lottery"&gt;......&lt;/div&gt; 这里我们将整个div中都定义为这个控制器的作用域，在这个作用域中，我们可以定义需要用到的元素变量，绑定数据和方法等。 之后主要分为四个大的div元素，和前面分析的一样，代表四种页面效果。这里设置每个div的名称时有个小技巧，即设置为”step1”、”step2”、”step3”、”step4”，这样后面在控制页面元素的时候，获取id的字符串，进行切换等操作都会相对比较方便。 第一个页面元素中主要是一个开始按钮，并用ng-click方式绑定了对应的方法： 1&lt;button ng-click="start()"&gt;开始&lt;/button&gt; 第二个页面元素主要是调用ng-repeat指令，这个指令可以用来遍历数组。同时用双大括号绑定了奖品的名称。这里最重要的是闪烁样式的确定，利用ng-class指令可以进行动态控制： 12345&lt;div ng-repeat="item in items" id="&#123;&#123;item.id&#125;&#125;" class="item" ng-class="&#123;'active':item.status&#125;"&gt; &#123;&#123;item.name&#125;&#125;&lt;/div&gt; 这里添加元素样式的方法是采用定义key/value的方式，即当“item.status”的值为true的时候，将”active”样式添加上去，反之则不添加，这样就可以实现闪烁样式的添加与删除了。 第三个页面元素主要是“重新开始”和“修改奖品”两个选择a元素的添加，同时用ng-click绑定对应的方法即可： 123456&lt;a href="javascript:void(0);" ng-click="reset()" class="reset"&gt; &lt;img src="images/reset.png"&gt;重新开始&lt;/a&gt;...... 这里值得注意的是，href=&quot;javascript:void(0);&quot;代表当触发a元素的时候，去执行相应绑定的js函数而不是去跳转地址。 第四个元素页面，主要是关于奖品的修改，除了和前面类似的一个返回按钮的设置之外，主要是增加和删除奖品两个部分的实现。 1234&lt;form ng-submit="add()"&gt; &lt;input type="text" class="add" ng-model="name" required placeholder="名称"&gt; &lt;input type="submit" class="btn" value="添加"&gt;&lt;/form&gt; 用ng-submit指令绑定对应方法，当type属性为submit的按钮被点击时，就会触发这个方法。ng-model指令将输入框中的输入值和name变量进行了双向绑定。 1234567&lt;ul&gt; &lt;li ng-repeat="item in items"&gt; &lt;span&gt;&#123;&#123;item.id&#125;&#125;&lt;/span&gt; &lt;span class="span"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;a href="javascript:void(0);" ng-click="del(item.id)"&gt;删除&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 而关于删除奖品这部分，先用ng-repeat指令循环遍历把奖品的信息和删除键都陈列出来，然后在删除键那里用ng-click绑定控制器中删除的方法即可。 js控制代码分析首先还是angularjs控制器的正常代码定义格式： 1234angular.module("lottery", []) .controller('ctrl_lottery', ['$scope', '$timeout', function($scope, $timeout) &#123; ...... &#125; 其中angular.module定义了 angular模块，是angularjs的代码入口，其中的名称就是前面页面中用ng-app绑定的名称。然后定义了控制器，控制器名称也与前面页面代码中绑定的名称一致，并注入需要用到的$scope和$timeout对象。 初始化方法用items来保存包含所有奖品的对象数组，然后定义两个通用的方法： 123456789$scope.$$ = function(id) &#123; return document.getElementById(id); &#125;;$scope.showhide = function(pre, nex) &#123; pre = "step" + pre; nex = "step" + nex; $scope.$$(pre).style.display = "none"; $scope.$$(nex).style.display = "block"; &#125;; 第一个方法根据元素id号来返回元素对象，第二个方法是切换页面元素的方法，只需传入对应的数字，即可完成页面切换，通过让前面一个页面隐藏和后面一个页面显示来达到效果，从这里也可以看出前面设置id的小技巧的用处了。 抽奖方法首先调用showhide()方法切换页面，然后定义循环圈数，其中最后选定第几号产品将随机产生： 1var selkey = Math.floor(Math.random() * $scope.items.length); 方法Math.random()随机产生一个大于等于0小于1的数字，然后乘以总个数之后再利用Math.floor方法进行向下取整，可以得到对应奖品的随机数字。 定义next()方法实现选中下一个进行闪烁，去掉上一个闪烁样式的效果： 12345678var next = function(key) &#123; $scope.items[key].status = true; if((key - 1) &gt;= 0) &#123; $scope.items[key -1].status = false; &#125; if(key == 0) &#123; $scope.items[$scope.items.length - 1].status = false; &#125; 具体通过对status标志的布尔值改变来实现。这里注意一旦超过一圈需要利用总个数处理判断。 $timeout方法是这个实现效果中的核心方法，实现思路是先判断跳动中当前的数字和总个数的关系，如果已完成一圈需要将代表圈数的变量减一，否则继续递归调用next()方法，直到circle圈数达到规定圈数，同时选中的奖品的所属次序也等于随机取的值为止： 123456789101112131415var timer = $timeout(function() &#123; if(circle &lt;= 0 &amp;&amp; selkey == key) &#123; $scope.showhide(2, 3); $scope.result = $scope.items[key].name; return; &#125; if($scope.items.length == key + 1) &#123; circle--; &#125; if($scope.items[key + 1]) &#123; next(key + 1); &#125; else &#123; next(0); &#125; &#125;, 100); 奖品显示页面方法这是第三个页面，除了显示奖品之外，只有重新开始抽奖和进入修改奖品页面这两个键，只需直接调用前面定义好的通用切换页面的方法即可： 123456$scope.reset = function() &#123; $scope.showhide(3, 1); &#125;; $scope.edit = function() &#123; $scope.showhide(3, 4); &#125;; 增删奖品的页面方法其实本质上就是对数组元素的增加或是删除，首先是增加奖品的方法： 1234$scope.add = function() &#123; var last_id = lastid(); $scope.items.push(&#123;id: last_id, name: $scope.name, status: 0&#125;); &#125;; 这里面用到了一个获取最后一个元素id号的方法，这个方法主要通过angular.foreach()遍历数组，从而在遍历结束时获取得到最后一个id号。获取了之后再加一，并采用数组的push()方法将增加的对象导入对象数组的最后一位即可。 下面是删除奖品的方法： 1234567$scope.del = function(id) &#123; angular.forEach($scope.items, function(value, key) &#123; if(id == value.id) &#123; $scope.items.splice(key, 1); &#125; &#125;) &#125;; 同样采用angular.foreach()遍历数组，这里需要注意的是，在这第二个参数即调用函数里面的参数，第一个代表的是数组元素值，第二个代表索引值。然后删除的方法是采用splice()方法，这个方法第一个参数代表删除的初始位置，第二个参数代表删除的个数。 总结在练习制作基于AngularJS的抽奖系统demo之后，加深了自己对于AngularJS制作单页应用开发的理解，也为自己后面的继续学习打下基础。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript关于DOM编程的最佳实践]]></title>
      <url>%2F2017%2F01%2F16%2FJavaScript%E5%85%B3%E4%BA%8EDOM%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[前言本博客记录总结了JavaScript关于DOM编程的一些最佳实践。 最佳实践web性能优化 尽量减少访问DOM只要是查询DOM中的某些元素，浏览器都会搜索整个DOM树，从中查找可能匹配的元素。1234567if(document.getElementsByTagName("a").length &gt; 0)&#123; var links = document.getElementsByTagName("a"); for(var i=0;i&lt;links.length;i++)&#123; //do something &#125;&#125; 上述代码中，执行document.getElementsByTagName(&quot;a&quot;).length时，会搜索整个DOM树；执行document.getElementsByTagName(&quot;a&quot;);时，会再次搜索整个DOM树。当DOM元素较多时，搜索整个DOM树是一个很耗时的操作。针对上述代码，作出如下优化：将第一次DOM树搜索的结果保存至一个变量中，将搜索次数减少1次。1234567var links = document.getElementsByTagName("a");if(links.length &gt; 0)&#123; for(var i=0;i&lt;links.length;i++)&#123; //do something &#125;&#125; 尽量减少文档中的标记数量。过多不必要的元素只会增加DOM树的规模，进而增加遍历DOM树以查找特定元素的时间。 将多个js文件合并并放置在合适的位置将多个js文件合并，可以减少HTTP请求次数。 根据HTTP规范，浏览器每次从同一个域名中最多只能同时下载2个文件。 将引入的外部js文件的&lt;script&gt;标签放置到文档的末尾（&lt;/body&gt;标签之前），可以使页面更快的加载。若将&lt;script&gt;标签放置于&lt;head&gt;中，则执行到&lt;script&gt;标签时，浏览器会先加载js文件，加载完成后才会执行&lt;body&gt;标签中的内容，才会创建DOM树，这样会影响页面加载速度。 压缩脚本脚本文件编写完成后，进行脚本压缩，可以减少文件体积，减轻服务器压力。在实际的工程中，可以保存2个版本的脚本：一个工作副本，用于修改，调试和注释；一个精简副本，压缩之后上传到服务器。精简副本（压缩后的脚本）一般在文件名中后缀上min进行标识。 常用的脚本压缩工具如下所示。[1] Douglas Crockford的JSMin[2] Yahoo的YUI Compressor[3] Google的Closure Compiler[4] Javascript压缩混淆工具比较分析 平稳退化如果正确地使用了js脚本，就可以让访问者在他们的浏览器不支持js或者禁用js的情况下，仍然能够顺利地访问你的网站，最基本的操作仍然能顺利实现（虽然有可能部分功能无法使用），这就是平稳退化。（Graceful Degradation，也叫做优雅降级） 此处以Google网站为例，说明平稳退化。访问Google网站，若此时浏览器支持js，点击右上角的Google应用图标，则会弹出一个下拉框，下拉框中显示了各种Google应用；若浏览器禁用了js或者不支持js，点击右上角的Google应用图标，则会跳转至Google Product网页。 上述功能，可以用下述代码实现。1&lt;a href="https://www.google.com/intl/zh-CN/about/products" onclick="myFunctionName(); return false"&gt;Baidu&lt;/a&gt; 当浏览器支持js时，点击&lt;a&gt;标签，执行myFunctionName()函数（实现对应的效果，比如显示一个下拉框）；此时，由于return false的存在，会阻止&lt;a&gt;标签的默认行为，禁止跳转至新的界面。若浏览器不支持js，则点击 &lt;a&gt;标签，会执行&lt;a&gt;标签的默认行为，跳转至href指定的网址中。 本章节参考资料：[1] JavaScrtip之平稳退化[2] 渐进增强与平稳退化[3] javascript平稳退化 渐进增强 所谓的”渐进增强”就是使用一些额外的信息层去包裹原始数据。按照”渐进增强”原则创建出的网站几乎（如果不是“全部”的话）都会支持”平稳退化”。 渐进增强原则基于这样一种思想：你应该总是从最核心的部分，也就是从内容开始。应该根据内容使用标记良好的结构；然后再逐步加强这些内容。这些增强工作可以是通过CSS改进呈现效果，也可以是通过DOM添加各种行为。如果你使用DOM添加内容核心，那么你添加的未免太迟了，内容应该在刚开始编写文档时就成为文档的组成部分。 例如，1&lt;p&gt; Welcome,Shanghai! &lt;/p&gt; 上述代码中的&lt;p&gt;元素时页面中最核心的内容。下面考虑渐进增强，若页面支持CSS3，可以对其样式修饰。即使页面不支持CSS3，页面仍然能正常显示，符合“平稳退化”。在判断文档中是否支持CSS或者js或者DOM行为等时，可以采用对象检测(Object Detection)（参见5.4 向后兼容 章节）。 本章节参考资料：[1] 什么是“平稳退化”和“渐进增强”理念？ 向后兼容1234if(method)&#123; statements;&#125;//else&#123; &#125; 对象检测(Object Detection)的使用方式如上述代码所示。将某一个方法method打包在if语句中，若支持该方法，则执行相应的操作。 这样编写代码，可以保证向后兼容。即若浏览器对js或DOM支持程度较高，支持某些的方法，则调用该方法。对于比较古老的浏览器，若不支持该方法，则执行else语句中的内容。从而保证了对新浏览器或新语法的支持，这就是向后兼容。 向后兼容的实例如下所示。123if(document.getElementsByClassName)&#123; var content = document.getElementsByClassName("content");&#125; 工程中更常用的做法为若不支持该方法，则返回false。使用或符号，可以同时检测多个方法。12if(!method1 || !method2 || !method3) return false;//do something with these methods 或者123var support = method1 &amp;&amp; method2 &amp;&amp; method2if(!support) return false;//do something with these methods]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中声明的提升]]></title>
      <url>%2F2017%2F01%2F04%2FJavaScript%E4%B8%AD%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8F%90%E5%8D%87%2F</url>
      <content type="text"><![CDATA[前言本文主要记录和总结了JavaScript中关于声明提升的概念和相关注意事项。 提升（Hoisting）我们常习惯将var a = 2; 看作是一个声明，而实际上JS引擎并不这么认为。它将var a和a = 2当作两个单独的声明，第一个是编辑阶段的任务，而第二个是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理，可以将这个过程形象地想象成所有的声明（函数和变量）都会被“移动”到各自作用域的最顶端，这个过程称为提升(Hoisting)。 注意 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。 变量声明和函数声明会被提升，但是函数表达式声明不会被提升。 变量声明和函数声明都会被提升，但是当两者同时出现时，首先提升的是函数声明，其次才是变量声明。 下面给出具体的实例说明。（1）只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。123a = 2;var a;console.log(a); // 2 变量声明var a会被提升至作用域顶端，执行代码输出2。上述代码等效于123var a;a = 2;console.log(a); // 2 而对于下述代码，只会将变量声明提升，变量赋值不会提升，故输出undefined。12console.log(a); // undefinedvar a = 2; 上述代码等效于123var a;console.log(a); // undefineda = 2; （2）变量声明和函数声明会被提升，但是函数表达式声明不会被提升。12345foo();function foo()&#123; console.log(a); // undefined var a = 2;&#125; 上述代码中，函数声明会被提升，最终输出结果为undefined。上述代码等效于123456function foo()&#123; var a; console.log(a); // undefined a = 2;&#125;foo(); 函数声明会被提升，但是函数表达式声明不会被提升。对于下述代码中，函数表达式并不会被提升。123456foo(); //不是ReferenceError,而是TypeErrorbar(); //ReferenceErrorvar foo = function bar()&#123; console.log(a); // undefined var a = 2;&#125;; 上述代码等效于123456789var foo;foo(); //不是ReferenceError,而是TypeErrorbar(); //ReferenceErrorfoo = function ()&#123; var bar = ... self ... var a; console.log(a); // undefined a = 2;&#125;; 变量标识符foo被提升至作用域顶端，因此当执行foo()时，作用域中已经存在foo变量，作用域查找正常，故不是ReferenceError，但是由于采用函数表达式声明的方式创建函数foo()，函数表达式声明并不能被提升，故此时foo未被赋值，执行foo()时，foo()由于对undefined值进行函数调用而导致非法操作，因此会抛出TypeError。 不论是匿名函数表达式，还是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。var foo = function bar(){};会被解释成为1234foo = function ()&#123; var bar = ... self ... //...&#125; 因此，在执行bar()时，作用域查找失败，会抛出ReferenceError，而不是TypeError。 （3） 变量声明和函数声明都会被提升，但是当两者同时出现时，首先提升的是函数声明，其次才是变量声明。12345678910foo(); //1var foo;function foo()&#123; console.log(1);&#125;foo = function()&#123; console.log(2);&#125; 上述代码在执行过程中等效于123456789function foo()&#123; console.log(1);&#125;foo(); //1foo = function()&#123; console.log(2);&#125; 变量声明和函数声明都会被提升，但是当两者同时出现时，首先提升的是函数声明，其次才是变量声明。因此，函数声明function foo(){..}首先被提升。其次，提升变量声明foo,但是此时作用域中已经有foo变量，因此var foo;属于重复的声明，因此被忽略了。最后，foo = function(){..}属于函数表达式声明，不会被提升。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web页面加载速度优化实战]]></title>
      <url>%2F2016%2F12%2F27%2FWeb%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%2F</url>
      <content type="text"><![CDATA[前言本文主要介绍了关于优化Web页面加载速度方面的一些技巧与方法。 Web页面加载信息查看浏览器中打开控制台，在Network栏目下，可以获取Web页面的HTTP请求次数，传输的数据量大小，加载完成时间等信息。以百度首页为例，其web页面加载信息如下图所示，百度首页加载过程中，HTTP请求次数为48，数据传输量为37.5KB，加载完成耗时3.76s。 一般情况下，一个网页 4s 内加载不完，就会使用户失去耐心，造成网站流失很大一部分用户。移动端网页加载速度会稍慢于PC端。 优化图片图片在网络流量中占有很大的比重，因此，优化图片对于减少流量有着至关重要的作用。 合并小图片很多页面有很多小图标，一个一个加载就相当于一个一个请求。将这些小图片合并成一个大图片，用CSS控制显示范围，这样就只需要一个请求即可加载完所有小图片，瞬间就会减少很多网络请求。 优化图片格式很多图片没有经过优化直接上传到网页中会占用很多额外的流量。比如一张屏幕大小的截图，用截图工具直接截图后的大小大概有 1MB ，此时直接上传到网页中就直接占用了1MB流量，但其实我们完全可以只牺牲它40% 的质量换取缩小 10 倍的大小。 本章节参考资料：[1] 前端图片优化机制[2] 图片优化[3] 网站开发中，如何将一张图片压缩得更小？[4] WebP 探寻之路[5] A new image format for the Web - WebP 图片格式优化工具如下所示。 [1] PhotoShopPS中打开图片，“文件”菜单中选择“导出 -&gt; 存储为Web所用格式”。 虽然存在多种的图片格式，但是依据压缩方法不同，所有的图片都能进一步归类为两大类别：无损和有损。无损数据压缩保证了图像在没有任何品质和信息丢失的情况下重现，而有损数据压缩的结果就是可能造成品质和信息的丢失。在平面设计领域最主流的无损媒介格式包括GIF，PNG，以及TIFF，而JPEG是最主流的有损压缩的图形格式。 一般情况下jpg图片选择品质中即可，png 格式图片选择 png8 即可。但是需要注意的是，有透明背景的 png图片要选择 png24 ，否则透明背景中会出现白边。gif 图片选择 gif64 无仿色即可。 一般经过优化的图片大小至少会有 3倍之差，原图片越大，优化的结果会越好。 [2] 智图智图是腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台，其功能包括针对png，jpeg，gif等各类格式图片的压缩，以及为上传图片自动选择最优的图片格式。同时，智图平台还会为用户转换一份webp格式的图片。此外，目前智图开放的API接口已被封装为gulp插件，方便用户接入在本地运行。iSparta效果同智图，可以通过npm安装。 [3] 其余图片压缩工具(如TinyPNG等)在此不具体给出，可以参考12款实用免费批量图片体积优化压缩工具。 使用CDN加载第三方资源通过CDN加载第三方资源，减少网站自身服务器的压力。例如，通过CDN加载jquery。1&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"&gt;&lt;/script&gt; 使用CDN储存静态资源一般网站90%的流量都用于静态资源的加载。除了用CDN加载第三方资源外，还可以将Web页面的静态资源（如图片，视频等）存储在CDN中，并在Web页面中引入，这样可以进一步减小服务器的开销，让服务器只专注于提供数据或者网页渲染服务。常用的CDN如]七牛云等。 合并压缩JS和CSS对多个JS文件或多个CSS文件进行合并，可以减少HTTP请求次数；对JS文件或者CSS文件进行压缩，可以减少页面加载时的数据传输量，缩短页面加载时间。 使用WebPack可以对JS和CSS文件进行合并与压缩。 代码优化本部分可以参考Yahoo - Best Practices for Speeding Up Your Web Site。 HTTP2 &amp; gzipHTTP2 是以 SPDY 为基础开发的。 SPDY 系列协议由谷歌开发，于 2009 年公开。它的设计目标就是降低 50% 的页面加载时间，所以 HTTP2 在很大程度也是为了优化页面加载时间，同时 HTTP2 支持多路复用，简单说就是所有的请求都通过一个 TCP 连接并发完成。 gzip是一种压缩网页的技术，当然压缩网页进行传输的代价就是给服务器增加一些压缩的负担，当然这种牺牲是值得的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[The Egg-Drop Numbers]]></title>
      <url>%2F2016%2F12%2F16%2FThe%20Egg-Drop%20Numbers%2F</url>
      <content type="text"><![CDATA[TopicSuppose that we wish to know which windows in a 36-story building are safe to drop eggs from, and which will cause the eggs to break on landing. We make a few assumptions: An egg that survives a fall can be used again. A broken egg must be discarded. The effect of a fall is the same for all eggs. If an egg breaks when dropped, then it would break if dropped from a higher window. If an egg survives a fall then it would survive a shorter fall. It is not ruled out that the first-floor windows break eggs, nor is it ruled out that the 36th-floor windows do not cause an egg to break. Analysis If only one egg is available and we wish to be sure of obtaining the right result, the experiment can be carried out in only one way. Drop the egg from the first-floor window; if it survives, drop it from the second floor window. Continue upward until it breaks. In the worst case, this method may require 36 droppings. So, when we have 2 eggs and one eggs has been broken, then we should use one egg strategy to continue the experiment. Solution 1 数学猜想反推法假设题目所要求的策略存在，该策略可以保证在最坏情况下至多需要扔K次鸡蛋就可以找出临界楼层。此时可以将问题转化为：如果只允许扔K次鸡蛋，能确定的最高的楼层是多少。 现在思考， 第一次鸡蛋应该从哪个楼层扔下? 因为此时我们有两个鸡蛋，为了在有限次数内检查尽可能高的楼层。第一次扔的时候，我们会希望能尽可能高一些 如果鸡蛋没碎，我们就能排除掉越多的楼层。 但是很显然，第一次扔的楼层不能过高，因为万一鸡蛋碎了，第二个鸡蛋就只能从第一层开始尝试起。 那么第一次扔的楼层最高可以选第几层呢？ 答案是第K层。 考虑最坏的情况，当我们从第K层扔下的时候，最坏的情况有可能是临界层为(K-1)层, 此时就需要尝试K次（用剩下的一个鸡蛋从第1层逐层试验到第(k-1)层），才能找到这个临界层。如果第一次尝试的楼层比K大， 显然会导致最大尝试次数超过K，不符合我们的假设。因此，我们有推论1： 推论1若最大尝试次数为K次时，最优策略第一次必然只能从第K层扔下。 在推论1的基础上，求解尝试K次能检查的最多楼层数。 由于第一次从K层扔下时，我们已经用掉了一次尝试机会，此时只能再尝试K-1次。这样，我们可以第二次尝试的楼层数向上增加K-1层， 即为 K + (K-1)=2K-1。如果再高，例如第二次我们从2x层扔下，我们在最坏情况下（临界楼层为2x-1），需要尝试的次数会变成x+1, 不符合我们的假设。 这样依次类推，第三次向上的增量就只能为 K-3, 第四次向上的增量就只能为 K-4。最后一次向上的增量为1。 此时，我们可以得出结论：如果只能尝试K次，我们能检测的最高楼层为 K+(K−1)+(K−2)+(K−3)….+2+1=(K*(K+1))/2。 令(K*(K+1))/2 &gt;= 36, 求解得 K &gt;= 8。因此，对于给定2个鸡蛋和36层楼层的情况下，尝试的最少次数为8次。K=8时的尝试流程如下图所示。 Refer UMD-CS-Egg-Drop for more information. The spare address is here. Solution 2 Dynamic Programming (DP-动态规划法)对于给定的2枚鸡蛋，第一枚鸡蛋从哪一层楼开始扔就显得至关重要了。如果第一枚鸡蛋碎了，那就回到只有一枚鸡蛋的问题了。 该问题可以采用动态规划策略求解。 Dynamic programming (also known as dynamic optimization) is a method for solving a complex problem by breaking it down into a collection of simpler subproblems, solving each of those subproblems just once, and storing their solutions – ideally, using a memory-based data structure. The next time the same subproblem occurs, instead of recomputing its solution, one simply looks up the previously computed solution, thereby saving computation time at the expense of a (hopefully) modest expenditure in storage space. (Each of the subproblem solutions is indexed in some way, typically based on the values of its input parameters, so as to facilitate its lookup.) The technique of storing solutions to subproblems instead of recomputing them is called “memoization”. Dynamic programming algorithms are often used for optimization. A dynamic programming algorithm will examine the previously solved subproblems and will combine their solutions to give the best solution for the given problem. 采用动态规划法求解问题必须满足如下的条件：分割成的子问题是最优解的时候，原问题也是最优解。 显然该问题满足这一点，可以采用动态规划策略求解。假定楼层数为N，鸡蛋数为M，第一次扔鸡蛋的层数为K，所需的扔鸡蛋最小次数为EggDrop(N,M)。当第一次扔鸡蛋选在第K层时， 若鸡蛋摔破，则问题转化为用剩下的(M-1)枚鸡蛋测试剩下的(K-1)层楼，即EggDrop(k-1,M-1) 若鸡蛋没有摔破，则问题转化为用M枚鸡蛋测试剩下的(N-K)层楼，即EggDrop(N-K,M) 因此，有如下表达式： EggDrop(N, M) = 1 + min{max{EggDrop(K-1, M-1), EggDrop(N-K,M)}}, EggDrop(1, M)=1 对应的C++代码为12345678910111213141516171819202122232425262728293031323334353637# include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;int EggDrop(int N, int M) &#123; //楼层数为0或1 if (N == 1 || N == 0) &#123; return N; &#125; //鸡蛋数为1,最差情况下测试次数为N if (M == 1) &#123; return N; &#125; //其余情况 int subPro, K; //K为第一枚鸡蛋落下的楼层数，subPro为转换为的子情况计数 int min = INT_MAX; //最小值 for (K = 1; K &lt;= N; K++) &#123; subPro = max(EggDrop(K - 1, M - 1), EggDrop(N - K, M)); if (subPro &lt; min) &#123; min = subPro; &#125; &#125; return (min + 1);&#125;int main() &#123; int M = 2, N = 10; //鸡蛋数M 楼层数N cout &lt;&lt;"Minimum number of trials in worst case with "&lt;&lt;M&lt;&lt;" eggs and "&lt;&lt;N&lt;&lt;" floors is "&lt;&lt;EggDrop(N,M)&lt;&lt; endl; system("pause"); return 0;&#125; 该代码复杂度为O(2^N),对于N=36情况，本地电脑很难计算出结果。重叠的子问题见下图所示。 下面考虑用动态规划（DP）方法优化。在DP中，保存子问题的结果，避免重复计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;#include &lt;vector&gt;using namespace std;int EggDrop(int M, int N) &#123; /* eggFloor[i][j] 表示对于 i个鸡蛋j层楼，需要的最少测试次数 */ vector&lt; vector&lt;int&gt; &gt; eggFloor(M + 1, vector&lt;int&gt;(N + 1)); int i = 0, j = 0; int tmp = 0; int K = 0, subPro = 0; //K为第一枚鸡蛋落下的楼层数，subPro为转换为的子情况计数 for (tmp = 0; tmp &lt;= M; tmp++) &#123; eggFloor[tmp][0] = 0; //楼层数为0时 eggFloor[tmp][1] = 1; //楼层数为1时 &#125; eggFloor[0][1] = 0; //楼层数为1时,鸡蛋数为0时 //鸡蛋数为1时和0时 for (tmp = 0; tmp &lt;= N; tmp++) &#123; eggFloor[1][tmp] = tmp; eggFloor[0][tmp] = 0; &#125; //其余情况 最优子结构 递推求解 for (i = 2; i &lt;= M; i++) &#123; //鸡蛋数外循环 for (j = 2; j &lt;= N; j++) &#123;//楼层数内循环 eggFloor[i][j] = INT_MAX; for (K = 1; K &lt;= j; K++) &#123; subPro = 1 + max(eggFloor[i - 1][K - 1], eggFloor[i][j - K]); if (subPro &lt; eggFloor[i][j]) &#123; eggFloor[i][j] = subPro; &#125; &#125; &#125; &#125; return eggFloor[M][N];&#125;int main() &#123; int M = 2, N = 36; //鸡蛋数M 楼层数N cout &lt;&lt; "Minimum number of trials in worst case with " &lt;&lt; M &lt;&lt; " eggs and " &lt;&lt; N &lt;&lt; " floors is " &lt;&lt; EggDrop(M, N) &lt;&lt; endl; system("pause"); return 0;&#125; 参考资料[1] Egg Dropping Puzzle[2] The Egg-Drop Problem[3] Egg Drop[4] 清晰解读：扔鸡蛋问题[5] 再谈大楼扔鸡蛋问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端数据可视化开源库介绍]]></title>
      <url>%2F2016%2F12%2F02%2F%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E6%BA%90%E5%BA%93%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[前言数据可视化主要分为可视化工具（在线生成图类）以及可视化工具库。下面对前端中常用的数据可视化开源库进行介绍。 数据可视化开源库D3D3.js是目前 Web 端评价最高的 Javascript 可视化工具库，其实例丰富，提供了大量线性图和条形图之外的复杂图表样式（ Voronoi 图、圆形集群等），易于实现调试数据。且能够通过扩展实现任何可以想到的数据可视化效果。 D3.js与 jQuery 类似，D3 直接对 DOM 进行操作，这是它与其它可视化工具的主要区别所在：它会设置单独的对象以及功能集，并通过标准 API 进行 DOM 调用。 D3的缺点主要表现为学习曲线太过严苛（学习难度较高，学习成本较大），数据“生命周期”模式不够直观，要达到理想使用效果需要用户深入理解JavaScript。 E-chart E-chart由百度团队开发，实例较丰富，相对于d3来说，中文资料和文档较全，使用非常方便。 比较容易学习，上手较快。 E-chart基础图形都有，地图也有(扩展不多)，但缺少类似于D3的顶级图表绘制功能。 E-chart提供了很多参数接口，但是不能自己定义新的图形样式。infoVisinfoVis支持WebGL，可以和D3框架配合。infovis也提供了链式方法来操作DOM。但是，其demo和参考资料较少。CesiumCesium专注于地理数据可视化，可以在 Web 浏览器中绘制 3D/2D 地球。Cesium无需任何插件即可基于 WebGL 来进行硬件加速，并且具有跨平台、跨浏览器的特点。其本身基于 Apache 开源协议，支持商业及非商业项目。其缺点表现为可视化样式不太美观，速度较慢。参考资料如下所示。[1] Cesium[2] Cesium Github Page##Highcharts DemoHighcharts Demo 类库大小超轻量级，并且性能非常好，支持所有浏览器，但对于不同设备性能不太一样 价格初始价格对于个人开发者或者小团队来说价格很低 浏览器支持老式浏览器和现代浏览器都支持的非常好 个人支持一般的问题好解决，但是一旦遇到了关键问题，个人支持非常有限 支持图形支持图形相对于fusioncharts来说，比较少。和E-chart差不多，地图比E-chart好，但也只是静态展示。Fusioncharts 支持不同类型图表提供了90多种图表和965种地图自定义并且有实际例子。自定义图表类型非常简单，包含了很多直接可以使用的例子，并且拥有很大的库封装器和插件。 提供了官方的封装器和插件 浏览器和设备支持支持所有浏览器（IE6） 设备高级特性提供了很多高级特性，宏，可编辑图表 个人支持得到的支持非常快 体积非常重，如果是基于web的应用会成问题，但是App会好些 价格价格相对于前面有些贵 总结可跨平台、跨浏览器的 Flash 图表解决方案，但是不推荐使用，因为体积较大，十分笨重，官方demo加载都很慢AnyChart 基于 Flash/JavaScript(HTML5) 的图表解决方案 可以轻松地跨浏览器、跨平台工作 可以通过 XML 格式获取数据，该方式让开发人员非常灵活地控制图表上的每一个数据点，而当图表数据点数量偏大时，则可以采用 CSV 数据输入，减小数据文件大小和图表加载时间。 支持图形少，没有地图类 框架收费（交互式图表和仪表功能） DemoAnyChart Demo amCharts 图表样式美观 基础类图表齐全 可以免费使用，但是会有网址链接。如果想消除网址链接，需要付费。 地图类交互较少 DemoamChartsChart.js 简单、面向对象，为设计和开发者准备的图表绘制工具库 基于 Html5，响应式，支持所有现代浏览器 轻量级，且支持模块化，即开发者可以拆分 Chart.js ，仅引入自己需要的部分进入工程 支持的图表类型较少，只有6种基础图表类型 DemoChart.js DemoChartist.js 代码简洁，配置简单在工程中，Chartist.js 的 CSS 和 JavaScript 分离，因此代码比较简洁，在应用时配置流程十分简单。 支持响应式生成的是响应式图表，可以自动支持不同的浏览器尺寸和分辨率 图表种类较少仅仅支持6种基础图表类型 DemosChartist.js DemoGoogle Chart 非常容易修改使用的DOM 定义定制的方法非常简单 界面可用性及其来自GDC（Google developers console）的开源网络支持 官方demo较少 DemosGoogle Chart Demo 总结使用人数较少，资料基本都是10年以前的，不推荐使用Leaflet 可以同时良好运行于桌面和移动端的 Javascript 可交互地图库 使用 OpenStreetMap 的数据，并把可视化数据集中在一起 内核库很小，但由丰富的插件可以大幅拓展其功能，常常被用于需要展示地理位置的项目 DemoLeaflet DemoDygraphs 图表类型基本上都是线图 DemoDygraphs Demo 放大时间段查看数据点的交互很棒icharts iCharts 有交互元素，可以从 Google Doc、Excel 表单和其他来源中获取数据。 免费版只允许使用基本的图表类型 Demoicharts Demo Reference[1] 前端数据可视化开源库[2] 14款基于javascript的数据可视化工具[3] 评测:四款面向数据可视化的超酷JavaScript工具[4] 13个Javascript框架：实现超棒数据可视化效果[5] 有哪些值得推荐的数据可视化工具？[6] 21款酷炫「数据可视化工具」，拿走不谢！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[明星介绍网站练习总结(三)]]></title>
      <url>%2F2016%2F11%2F27%2F%E6%98%8E%E6%98%9F%E4%BB%8B%E7%BB%8D%E7%BD%91%E7%AB%99%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作明星介绍网站demo过程中的一些心得和技巧，主要有三篇，这篇侧重于对表单部分实现的阐述和总结。 心得与技巧表单部分实现对于一个明星介绍网站来说，联系信息的公布还是比较重要的，所以很有必要构建一个联系表单。这里为了方便展示，我们不利用服务器端脚本来处理发送到后台的信息，而仅是创建一个html页面来进行调用来对提交信息的访客表示感谢。 页面设置这里会用的一些html5的标签，设置的表单联系信息主要包括访客的姓名、电子邮箱和想告诉作者的话等。具体代码实现如下： 123456789101112&lt;article&gt; &lt;h1&gt;联系作者&lt;/h1&gt; &lt;form method="post" action="thanks.html"&gt; &lt;label for="name"&gt;姓名：&lt;/label&gt; &lt;input type="text" id="name" placeholder="请输入您的名字" required /&gt; &lt;label for="email"&gt;邮箱：&lt;/label&gt; &lt;input type="email" id="email" placeholder="请输入您的邮箱" required /&gt; &lt;label for="textarea"&gt;留言:&lt;/label&gt; &lt;textarea placeholder="请输入您想告诉作者的话..." required&gt;&lt;/textarea&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/article&gt; 需要说明和注意的地方主要有以下几点： 整个表单需要放在form标签内，其中method是用来发送表单数据的http方法，这里使用的是post方法。action是规定当提交表单时向何处发送表单数据。这里补充引用w3school网站的一段话来说明一下post和get方法的选择问题。 如果希望获得最佳表单传输性能，可以采用 GET 方法发送只有少数简短字段的小表单。 一些服务器操作系统在处理可以立即传递给应用程序的命令行参数时，会限制其数目和长度，在这种情况下，对那些有许多字段或是很长的文本域的表单来说，就应该采用 POST 方法来发送。 如果你在编写服务器端的表单处理应用程序方面经验不足，应该选择 GET 方法。如果采用 POST 方法，就要在读取和解码方法做些额外的工作，也许这并不很难，但是也许你不太愿意去处理这些问题。 如果安全性是个问题，那么我们建议选用 POST 方法。GET 方法将表单参数直接放在应用程序的 URL 中，这样网络窥探者可以很轻松地捕获它们，还可以从服务器的日志文件中进行摘录。如果参数中包含了信用卡帐号这样的敏感信息，就会在不知不觉中危及用户的安全。而 POST 应用程序就没有安全方面的漏洞，在将参数作为单独的事务传输给服务器进行处理时，至少还可以采用加密的方法。 如果想在表单之外调用服务器端的应用程序，而且包括向其传递参数的过程，就要采用 GET 方法，因为该方法允许把表单这样的参数包括进来作为 URL 的一部分。而另一方面，使用 POST 样式的应用程序却希望在 URL 后还能有一个来自浏览器额外的传输过程，其中传输的内容不能作为传统a标签的内容。 label标签的使用，整个属性容易被忽略，但其实它可以通过for属性把一小段文本关联到表单的一个字段，可以增加可访问性，而尤其对于屏幕阅读器来说更是不可或缺。 HTML5的placeholder属性可以添加占位符文本，即在表单字段中显示默认的提示文本，会使用户觉得友好。还有HTML5提供的required属性，用于表示某个字段的值是必须填写不能留空的。 提交按钮的type属性得设置为submit，这样才能当用户点击提交按钮时触发提交表单的操作。 form对象文档中的每个表单元素其实都是一个form对象，每个form对象都有一个elements.length属性。这个属性返回表单中的包含的表单元素的个数。与childNodes.length相比较，后者是返回元素中国包含的所有节点的个数，而前者仅包含表单元素，所以两者是不同的。同理可知，form.elements是返回表单元素的数组，取得对应表单元素之后可以方便对之进行一些操作。 兼容旧版本对placeholder属性的不支持前面我们用placeholder属性添加了占位符文本，但是考虑到这是HTML5的特性，一些旧浏览器可能不会兼容，所以我们需要编写一个函数，使旧浏览器不兼容的时候也能达到相应效果。下面是函数的函数体： 1234567891011121314151617if (Modernizr.input.placeholder) return; for (var i=0; i&lt;whichform.elements.length; i++) &#123; var element = whichform.elements[i]; if (element.type == "submit") continue; if (!element.getAttribute('placeholder')) continue; element.onfocus = function() &#123; if (this.value == this.getAttribute('placeholder')) &#123; this.value = ""; &#125; &#125; element.onblur = function() &#123; if (this.value == "") &#123; this.value = this.getAttribute('placeholder'); &#125; &#125; element.onblur(); &#125; 首先我们检测浏览器是否支持placeholder属性，这里我们用到Modernizr，它是一个用来检测浏览器功能支持情况的 JavaScript 库。通过这个库我们可以检测不同的浏览器对于HTML5特性的支持情况。 然后我们通过前面说到的form对象的方法对表单元素进行循环遍历，并且跳过提交按钮，对它不做处理。 之后对原本元素里面的placeholder属性进行判断，如果有值则进行下面的操作。 最后添加两个事件处理函数，一个是onfocus事件，表单元素获得焦点时触发，一个是onblur事件，焦点移出表单字段时触发。这样我们就可以通过元素的value属性和className属性来对表单元素设置和移除默认值和样式了。 表单验证好的客户端验证可以帮助用户填好表单，避免提交未完成的表单，从而节省他们的时间。但是值得一提的是，服务器端的验证也是必不可少的，可以保护数据库和后台系统的安全，并不能被客户端验证所取代。 123function isFilled(field) &#123; return (field.value.length &gt; 1 &amp;&amp; field.value != field.placeholder);&#125; 这个函数检查了value属性的length属性，就能知道value中是不是没有任何字符，同时也比较value属性和placeholder属性的值，就可以知道用户是否对占位符文本没有改动，只有通过这两个验证才能返回true。 123function isEmail(field) &#123; return (field.value.indexOf("@") != -1 &amp;&amp; field.value.indexOf(".") != -1);&#125; 同样的，在对于电子邮件格式的检查上，我们至少需要确保表单字段中包含@和.这两个符号，才能使之通过验证，返回true。当然，我们也可以在css上或者是js上进行一些设置与处理，当无法通过验证时，样式发生改变或是出现一些提示性文字。 值得注意的地方是，我们可以通过onsubmit事件处理函数来添加验证行为，而且提交表单时的自动触发的submit事件，会被onsubmit事件所拦截，只有返回true的时候，才能使表单数据提交给服务器。 表单提交我们知道，Ajax技术的核心就是XMLHTTPRequest对象，它充当着浏览器的脚本(客户端)与服务器之间的中间人的角色。但是不同浏览器实现XMLHTTPRequest对象的方式不太一样。为了保证浏览器的兼容性，需要编写函数来获得不同类型或版本浏览器下的XMLHTTPRequest对象。 12345678910111213function getHTTPObject() &#123; if (typeof XMLHttpRequest == "undefined") XMLHttpRequest = function () &#123; try &#123; return new ActiveXObject("Msxml2.XMLHTTP.6.0"); &#125; catch (e) &#123;&#125; try &#123; return new ActiveXObject("Msxml2.XMLHTTP.3.0"); &#125; catch (e) &#123;&#125; try &#123; return new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123;&#125; return false; &#125; return new XMLHttpRequest();&#125; 前三个判断中主要是为了兼容不同IE版本浏览器中获得XMLHTTPRequest对象的方法。而其他浏览器中的相关方法主要就是new XMLHttpRequest(); 为了增加对用户的友好性，可以在Ajax请求刚启动时添加显示一个“正在载入”的图像，函数如下所示： 123456789function displayAjaxLoading(element) &#123; while (element.hasChildNodes()) &#123; element.removeChild(element.lastChild); &#125; var content = document.createElement("img"); content.setAttribute("src","images/loading.gif"); content.setAttribute("alt","Loading..."); element.appendChild(content);&#125; 具体做法是先把此dom元素里面的子元素全部删除，然后动态创建这个加载图像的元素。动态创建的过程主要是document.createElement()方法创建新元素，setAttribute()方法增加新元素的属性值，最后appendChild()方法添加入页面中。 接下来很重要的一步是将表单的值组织成URL编码的字符串，方法是循环遍历表单的每个字段，然后得到他们的名字和值，这里有个需要注意的地方，那些值中的一些特殊符号可能会带来歧义，从而引出传输的问题，所以需要用encodeURIComponent函数把值编码成URL安全的字符串，可以把有歧义的字符串转换成对应的ASCII编码。之后把数据用join函数联结即可 。具体代码如下：‘ 1234567var dataParts = []; var element; for (var i=0; i&lt;whichform.elements.length; i++) &#123; element = whichform.elements[i]; dataParts[i] = element.name + '=' + encodeURIComponent(element.value); &#125; var data = dataParts.join('&amp;'); 后面就是Ajax应用的一些正常步骤了： 1234567891011request.open('POST', whichform.getAttribute("action"), true); request.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); request.onreadystatechange = function () &#123; if (request.readyState == 4) &#123; if (request.status == 200 || request.status == 0) &#123; ...... request.responseText ...... &#125; request.send(data); return true; 最后还需要注意的一点是，有必要运用添加onsubmit事件来阻止默认的submit事件，通过发送ajax请求的成功与否来判断是否应该阻止表单继续提交，这样可以阻止浏览器重复提交表单。 总结这篇博文是我练习制作明星介绍网站demo总结的第三篇，侧重于对表单部分实现的阐述和总结。至此，关于这个demo练习的总结已经结束，总体来说，这个demo练习全面锻炼了我的html、css、javascript和ajax等前端技术，尤其是对于javascript dom的编程能力大大提升，收获颇丰。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[明星介绍网站练习总结(二)]]></title>
      <url>%2F2016%2F11%2F26%2F%E6%98%8E%E6%98%9F%E4%BB%8B%E7%BB%8D%E7%BD%91%E7%AB%99%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作明星介绍网站demo过程中的一些心得和技巧，主要有三篇，这篇侧重于对javascript实现一些具体功能和效果的总结。 心得与技巧javascript编写与技巧主页幻灯片效果实现移动函数的实现我们想最终实现的效果就是在主页下方有个小窗口，当我们用鼠标放置在导航链接上时，可以在小窗口那里对应显示不同的小图片，并以动画的形式进行切换。 首先需要准备好素材，这里我们根据窗口的大小将5张小图片按照水平方向合成一张图片，方便之后的效果实现。 由于我们是通过移动图片的方式实现幻灯片变换的动画效果的，所以我们需要编写一个移动函数moveElement(elementID,final_x,final_y,interval)，其中elementID是待移动的元素，final_x和final_y是元素需要移动到的目标位置，而interval是每次移动的间隔时间。这个函数主要实现思路是通过不断比较元素当前位置与目标位置的距离，然后增大或减小元素当前的位置，使之向目标位置移动，直到到达目标位置为止。 这个函数编写看似简单，其实有很多需要注意和优化的地方： 首先需要进行对象检测，如以下代码所示： 123456if (!elem.style.left) &#123; elem.style.left = "0px"; &#125; if (!elem.style.top) &#123; elem.style.top = "0px"; &#125; 为了防止元素的left和top属性不存在，导致后面的操作无法进行出现错误，需要先进行检测，如果不存在则人为赋给它们‘0px’的值。 由于元素的left和top属性值是字符串形式，为了获得数据使之方便在后面进行距离的比较，需要通过parseInt()函数对字符串进行解析，从而返回整数值。 为了使图片移动和变换的动画效果感觉平滑和迅速，我们在比较当前位置和目标位置的距离时，当距离大的时候我们可以使一次移动的距离也变大，反之变小，具体实现我们可以使每次移动距离为当前位置与目标位置距离的十分之一，并通过Math.ceil()函数向上取整，使不到1px的时候移动1px，从而可以使元素到达目标位置处，如下所示： 12345if (xpos &lt; final_x) &#123; var dist = Math.ceil((final_x - xpos)/10); xpos = xpos + dist; &#125; ...... 在每次移动之后将移动后的位置赋给元素的left和top属性的时候，注意要将整数值再转回为字符串，并在后面加上`+“px”，如下所示： 1234if (xpos &lt; final_x) &#123; var dist = Math.ceil((final_x - xpos)/10); xpos = xpos + dist; &#125; 整体不断移动的实现主要是通过setTimeout()函数递归调用此移动函数，调用方法如下所示： 12var repeat = "moveElement('"+elementID+"',"+final_x+","+final_y+","+interval+")"; elem.movement = setTimeout(repeat,interval); 为了防止用户在链接之间快速移动鼠标导致动画效果的滞后，需要在每次移动开始前调用clearTimeout()函数清除积累在setTimeout队列里的事件。但这里有个值得注意的地方，为了可以在函数中一开始就可以调用movement变量，我们需要将之设置为被移动元素的属性，如下所示： 123if (elem.movement) &#123; clearTimeout(elem.movement); &#125; 实现链接与图片切换的同步效果为了实现链接与图片切换的同步效果，其实就是对导航里的链接进行循环遍历，绑定onmouseover()事件，然后得到当年链接的href属性值，与对应的页面名称相比较，来决定图片应该如何移动，如下所示： 12345678910var links = document.getElementsByTagName("a"); for (var i=0; i&lt;links.length; i++) &#123; links[i].onmouseover = function() &#123; var destination = this.getAttribute("href"); if (destination.indexOf("index.html") != -1) &#123; moveElement("preview",0,0,5); &#125; if (destination.indexOf("about.html") != -1) &#123; moveElement("preview",-150,0,5); &#125; 幻灯片窗口的相关css设置这里有以下三点需要注意的地方： 父元素的position属性得设置为relative相对定位，而子元素的position属性得设置为absolute绝对定位，这样才可以方便地使用移动距离。 父元素的overflow属性设置为hidden，使溢出的部分隐藏。 为保证小窗口是出现在动画之上的，我们还需要设置小窗口的z-index属性，这里可以设置为99。 内部链接设置在篮球技术页面，我们可以看到有两个内部链接，当点击链接的时候，下面的对应内容会显示出来，而正常的时候是隐藏的。这样可以节省页面空间，也对用户友好。 主要实现方法就是外层循环遍历给链接添加onclick()函数，监听哪个链接被触发事件，而在事件函数内部再循环遍历内容块，可以根据内容块的id与触发的链接的id属性一致来使之显示，即设置display属性为block即可。 考虑到局部变量作用域的问题，如果想在事件函数中调用其他函数中的局部变量，可以将这个局部变量赋给一个元素自己创建的自定义属性，而这个属性的作用域是持久存在的。 如果想从链接的href属性中获取对应部分的id，由于在这个属性的开头有“#”表示内部链接，所以我们可以使用字符串的split()方法。这个方法是根据传入的参数分隔符将一个字符串分成多个部分，得到一个数组，每个数组元素都是一个字符串。针对当前情况，我们可以编写如下代码实现： 1var sectionId = links[i].getAttribute("href").split("#")[1]; 表格样式的js实现在“主要经历“页面有个表格的形式来展示明星的主要经历，其中表格中主要有两种样式，一是斑马纹样式，即表格奇数行和偶数行背景底纹颜色不同，二是当鼠标移至表格某一行上的时候，那一行的背景底纹色也会随之改变。而这些均是通过javascript来实现的。 第一种样式主要通过stripeTables()函数实现，具体代码如下： 1234567891011121314if (!document.getElementsByTagName) return false; var tables = document.getElementsByTagName("table"); for (var i=0; i&lt;tables.length; i++) &#123; var odd = false; var rows = tables[i].getElementsByTagName("tr"); for (var j=0; j&lt;rows.length; j++) &#123; if (odd == true) &#123; addClass(rows[j],"odd"); odd = false; &#125; else &#123; odd = true; &#125; &#125; &#125; 其实就是获得table的dom元素之后，再循环遍历表格里面的行，用一个变量保存当前是奇数行还是偶数行的信息，如果是奇数行则添加奇数行的样式，如果是偶数行则改变变量布尔值，等待下一次循环。 第二种样式主要通过 highlightRows()函数实现，具体代码如下： 1234567891011if(!document.getElementsByTagName) return false; var rows = document.getElementsByTagName("tr"); for (var i=0; i&lt;rows.length; i++) &#123; rows[i].oldClassName = rows[i].className rows[i].onmouseover = function() &#123; addClass(this,"highlight"); &#125; rows[i].onmouseout = function() &#123; this.className = this.oldClassName &#125; &#125; 获得表格中行的dom元素数组之后，对之进行循环遍历，这里我们需要添加onmouseover和onmouseout两个鼠标事件，前者是鼠标移动到元素上触发，后者是鼠标从元素上移开时触发。这里有个需要注意的地方，就是为了保证在鼠标移开时可以回到原来的样式，所以提前需要用个变量保存原来的元素样式，在鼠标移开时再赋回去。 总结这篇博文是我练习制作明星介绍网站demo总结的第二篇，主要侧重于对javascript实现一些具体功能和效果的总结，我们可以发现，即使是一些看起来比较简单的功能和效果，里面也会有很多值得注意和优化的地方，或是包含一些小技巧。下一篇将主要针对这个demo的表单部分进行阐述和总结。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[明星介绍网站练习总结(一)]]></title>
      <url>%2F2016%2F11%2F25%2F%E6%98%8E%E6%98%9F%E4%BB%8B%E7%BB%8D%E7%BD%91%E7%AB%99%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作明星介绍网站demo过程中的一些心得和技巧，主要有三篇，这篇侧重于整体部分的设置总结。 心得与技巧html/css 结构和样式设置站点和页面结构站点结构主要由图片文件、css文件、js文件和html文件组成，其中html文件除了主页index.html之外，根据内容划分的需要，还有另外的5个html文件，共同组成了这个明星介绍网站的基本结构。其中每个html页面的头部区域有相似之处，均由一张大的图片logo和导航区域组成，下面的页面内容部分则根据需求各有特色。值得注意的是，这里的标签我们运用html5的元素(如header、nav、article等)。 css设置css文件主要由reset.css和index.css两个css文件组成。reset.css文件主要是为了重设浏览器标签的样式表。因为浏览器的品种很多，每个浏览器的默认样式也是不同的。在切换页面的时候，浏览器的默认样式往往会给我们带来麻烦，影响开发效率。所以解决的方法就是一开始就将浏览器的默认样式全部去掉，更准确说就是通过重新定义标签样式。“覆盖”浏览器的CSS默认属性。如下面这种： 123456789section, header, article, nav &#123; display: block;&#125;* &#123; padding: 0; margin: 0;&#125;...... 其中设置那些html5的标签为块状元素也是为了考虑到兼容性，如果浏览器不支持html5的情况下，也不会对布局造成大的影响。有些css设置技巧在前面的博文中已有相关叙述。 javascript编写与技巧一些通用函数的编写如果想要在文档完全加载之后用到某个函数，则先需要用到addLoadEvent函数： 1234567891011function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125;&#125; 这个函数可以看成是共享onload事件，为了可以实现在页面加载完毕时可以执行任意多个函数的效果，先创建匿名函数来容纳旧函数和新函数。具体操作如下： 把现在传入的事件处理函数存入一个变量中。 判断如果这个处理函数上还没有绑定任何函数，则把新函数添加给它 如果如果这个处理函数上已经绑定一些函数了，则把新函数增加到现有指令的末尾。这样可以把页面加载完毕时执行的函数创建为一个队列。 我们知道在javascript中只有自带的insertBefore函数，可以把节点插入到另一个节点之前，而没有函数可以把节点插入到一个节点之后。而这个需求又是很常见的，所以编写一个insertAfter函数还是很有必要的。 12345678function insertAfter(newElement,targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement) &#123; parent.appendChild(newElement); &#125; else &#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; 具体操作如下： 通过parentNode属性找到目标节点的父节点。 通过lastChlid属性判断最后一个子节点是不是目标节点。 如果最后一个子节点是目标节点，则直接用appendChild方法添加待插入节点即可。 如果不是的话，则需要运用nextSibling属性和insertBefore方法，将待插入节点放在紧邻目标节点的下一个兄弟节点之前即可。 还有一个非常常用的函数是给一个元素追加新的class样式，我们给这个函数起名为addClass函数 12345678910function addClass(element,value) &#123; if (!element.className) &#123; element.className = value; &#125; else &#123; newClassName = element.className; newClassName+= " "; newClassName+= value; element.className = newClassName; &#125;&#125; 具体操作如下： 首先得判断原来的元素中有没有class样式，如果没有的话，直接将新的class通过元素的className属性赋给它即可。 如果已有class样式，则通过js中连接字符串的‘+’运算符，将原来的class样式加上一个空格字符串和新的class样式，再将新的字符串赋给元素的className属性即可。 页面切换时的设置技巧使当前页面导航链接突出显示首先我们会在css样式表中添加一个‘here’类，并给它设置相应的样式，作为当前界面突出显示的导航链接样式。然后重点就是在如何将这个样式放在当前界面的导航元素那里，为此，我们编写函数highlightPage()来实现这个功能。 首先进行对象检测，判断需要用到的DOM方法和一些元素是否存在，具体如下所示： 123456if (!document.getElementsByTagName) return false; if (!document.getElementById) return false; var headers = document.getElementsByTagName('header'); if (headers.length == 0) return false; var navs = headers[0].getElementsByTagName('nav'); if (navs.length == 0) return false; 这里有个地方需要注意一下，就是getElementsByTagName这个方法和getElementById不一样，它得到的是一个数组，即使只有一个元素，也是通过数组的[0]来得到。 然后获得所有导航链接，并对之进行循环遍历： 12var links = navs[0].getElementsByTagName("a"); for (var i=0; i&lt;links.length; i++) &#123; 下面是最重要的判断链接是否对应当前页面的方法，这里采取的是比较当前链接的URL和当前页面的URL，具体如下： 1234 var linkurl;linkurl = links[i].getAttribute("href");if (window.location.href.indexOf(linkurl) != -1) &#123; links[i].className = "here"; 这里通过getAttribute方法获取元素的href属性值，得到当前页链接的URL，然后通过window.location.href方法获取当前页面的URL，而比较方法是通过字符串的indexOf方法，这个方法返回传入参数的子字符串在调用方法的字符串里第一次出现的位置。如果没有匹配到则返回-1。通过判断是否匹配到就能得到链接是否对应当前页面的信息。得到之后赋予对应的class即可。 切换页面应用样式为了方便地在切换页面的时候可以应用不同的样式，可以利用js在上面这个函数中给每个页面的body元素添加id属性。具体如下： 12var linktext = links[i].lastChild.nodeValue.toLowerCase(); document.body.setAttribute("id",linktext); 这里可以在遍历的时候，找到当前a标签里面的最后一个节点，是文本节点，并通过nodeValue属性取得链接文本的值。为了设为id属性，再用toLowerCase()方法转换为小写，最后通过setAttribute()方法将body的id属性设为此值即可。 总结这篇博文是我练习制作明星介绍网站demo总结的第一篇，主要侧重于整体部分的总结和技巧说明，下一篇将侧重于对javascript实现一些具体功能和效果的总结。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中作用域问题]]></title>
      <url>%2F2016%2F11%2F17%2FJavaScript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[前言这篇文章主要记录和总结了关于JavaScript中作用域的一些问题。 词法作用域 作用域共有2种主要的工作模型。第一种是词法作用域，这是最为普遍的，被大多数编程语言采用。第二种是动态作用域，使用较少，诸如Perl，Bash脚本等语言在使用。JavaScript使用词法作用域。 词法作用域词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。 欺骗词法JavaScript中有2个机制可以“欺骗”（或修改）词法作用域：eval()和with(expression){statement}。二者的副作用都将导致引擎无法在编译时对作用域查找进行优化，导致性能降低，故不推荐使用。 with(expression){statement}本质上是通过将一个对象的引用当做作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建一个新的词法作用域（程序运行时）。参考 Mozilla Develop Network Website 了解更多。 用with从对象中创建出的作用域仅在with声明中有效，在外部作用域中无效。1234567891011121314151617181920function foo(obj)&#123; with(obj)&#123; a = 2; &#125;&#125;var o1 = &#123; a:3 &#125;;var o2 = &#123; b:2&#125;;foo(o1);console.log(o1.a); //2foo(o2);console.log(o2.a); //undefinedconsole.log(a); //2 但是这样会将a泄露至全局作用域中 执行foo(o1)时，a=2赋值操作找到了o1.a并将2赋值给它，这在后面的console.log(o1.a)中可以体现。而当执行foo(o1)时，o2传递进去，o2并没有a属性，因此不会创建这个属性，o2.a保持undefined；此时，在o2的作用域，foo(..)的作用域和全局作用域都没有找到标识符a，因此当执行a=2时，自动创建了一个全局变量（非严格模式下）。with这种将对象及其属性放进一个作用域并同时分配标识符的行为很让人费解。 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。 函数作用域和块作用域JavaScript中函数的定义函数声明（function statement）（函数语句） function name([param[, param[, … param]]]) { statements } 这是最常见的一种函数定义方式，使用function标识符和函数名创建。具有函数名的函数成为具名函数，没有函数名的函数成为匿名函数。123function double(x)&#123; return 2 * x; &#125; ####3.1.2 函数表达式 (function expression) function [name] ([param] [, param] […, param]) { statements }`函数名name可以省略。当省略函数名的时候，该函数就成为了匿名函数。 函数表达式（function expression）非常类似于函数声明（function statement），并且拥有几乎相同的语法。函数表达式与函数声明的最主要区别是函数名称（function name），在函数表达式中可忽略它，从而创建匿名函数（anonymous functions）。 123var x = function(y) &#123; return y * y;&#125;; 命名函数表达式（Named function expression）如果你想在函数体内部引用当前函数，则需要创建一个命名函数表达式。然后函数名称将会（且只会）作为函数体（作用域内）的本地变量。这样也可以避免使用非标准的 arguments.callee属性。1234567var math = &#123; 'factorial': function factorial(n) &#123; if (n &lt;= 1) return 1; return n * factorial(n - 1); &#125;&#125;; Function构造函数 new Function (arg1, arg2, … argN, functionBody)1var double = new Function("x", "return 2 * x;"); 使用Function构造函数，把参数列表和函数体都作为字符串传入。 Tip 不推荐使用 Function 构造函数创建函数,因为它需要的函数体作为字符串可能，这样会阻止一些JS引擎优化，也会引起其他问题。 JavaScript中匿名函数（Anonymous Function）匿名函数（Anonymous Function）常见的创建方式有2种。 函数表达式 (function expression)（同3.1.2章节） 123var x = function(y) &#123; return y * y;&#125;; 立即执行函数表达式 ( function( ){ } )( ) or ( function( ){ } ( ) )( function( ){ } )( ) 和 ( function( ){ } ( ) ) 这两种方式在功能上是一样的，根据个人喜好选择一种方法即可。 1234function (a,b) &#123; console.log(a+b); &#125;foo(2,3); //5 上述代码，声明了foo函数，foo存在于全局作用域中，可以认为是“污染”了全局作用域。函数foo()创建之后，必须显示地通过函数名调用才能执行这个函数。 若将上述代码修改为如下所示的立即执行表达式，函数名foo只能在( function( ){ ... } )( ) 中的...作用域中存在，并不会“污染”全局作用域。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 下述代码中，函数在创建完成后会自动地执行。这种模式成为IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression）。 区分函数声明和函数表达式的最简单的方法是看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明的位置）。如果function是声明中的第一个词，那么就是函数声明。否则，就是一个函数表达式，例如，( function( ){ ... } )( ) 中function 前的 (表明该语句是一个函数表达式。 12345678(function (a,b) &#123; console.log(a+b); //5&#125;)(2,3); // 或者(function foo (a,b) &#123; console.log(a+b); //5&#125;)(2,3); 块作用域（block-level scope）大多数类C语言和JavaScript都支持函数作用域；大多数类C语言也支持块级作用域，但是JavaScript并不支持块级作用域。如下代码所示。1234567891011#include &lt;stdio.h&gt; void main() &#123; int i=2; i--; if(i) &#123; int j=3; &#125; printf("%d/n",j); //Error: use an undefined variable:j&#125; C语言具有块级作用域，变量j是在if语句中创建的，因此，在if(){...}之外访问变量j，会出现Error: use an undefined variable:j。 块级作用域：任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。 而对于下述JavaScript代码，由于JS不支持块级作用域，因此，变量i的作用域是整个test()函数的作用域，调用alert(i)时会正常输出3。（for循环语句并没有创建一个块级作用域）123456functin test()&#123; for(var i=0;i&lt;3;i++)&#123; &#125; alert(i); //3&#125; test(); 为了使JS支持块级作用域，可以采用如下的方法： 采用闭包，编写立即执行函数表达式(function () { })();，借助函数作用域”实现”块级作用域的效果。12345678function test()&#123; (function ()&#123; for(var i=0;i&lt;4;i++)&#123; &#125; &#125;)(); alert(i); //Uncaught ReferenceError: i is not defined&#125; test(); 执行上述代码，由于for语句块放到了一个闭包之中，采用了立即执行函数表达式，当该函数调用完后，变量会被撤销。因此，调用alert(i)时会输出Uncaught ReferenceError: i is not defined。 使用with &amp; try/catch &amp; let &amp; const语句创建块级作用域。 本章节参考资料如下。[1] JavaScript的作用域和块级作用域概念理解 let和const 创建块作用域变量ES6中引入了let和const来创建块作用域变量，其中const创建的变量的值不能修改，否则会引起错误。1234567891011if(1)&#123; const num1 = 4; let num2 = 2; var num3 = 3; num1 = 1; //error num2 = 8;&#125;console.log(num1); //ReferenceErrorconsole.log(num2); //ReferenceErrorconsole.log(num3); //3 上述代码中，使用var创建的变量具有全局作用域，使用let和const创建的变量具有块作用域。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的闭包与this]]></title>
      <url>%2F2016%2F11%2F04%2FJavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E4%B8%8Ethis%2F</url>
      <content type="text"><![CDATA[前言本文主要对JavaScript中的闭包与this这两个概念进行较为详细地阐述。 闭包闭包简介 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。本质上，无论何时何地，如果将（访问它们各自词法作用域的）函数当做第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器，事件监听器，Ajax请求，跨窗口通信，Web Workes或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 闭包由两部分构成：函数和创建该函数的环境。即闭包 = 函数 + 创建该函数的环境。 ###5.1 循环和闭包12345for(var i=0;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i); &#125;,1000);&#125; 执行上述代码，并不会输出数字1~5，而是会以每秒一次的频率输出5次数字6。 延迟函数的回调会在循环结束时才执行。setTimeout()函数遵循如下机制：setTimeout是在任务队列结束的时候开始计时的，如果前面有进程没有结束，那么就等到它结束后在开始计时。 上述代码中，setTimeout()函数位于for循环中，for循环没有结束时，setTimeout()中的回调函数并不会执行。当for循环结束时，变量i的值为6。此时，setTimeout()函数前面的进程已经结束，可以执行回调函数，因此，会输出5个数字6。 若将上述代码修改为如下所示的代码，IIFE（Immediately Invoked Function Expression）会通过声明并立即执行一个函数来创建作用域。1234567for(var i=0;i&lt;=5;i++)&#123; (function()&#123; setTimeout(function timer()&#123; console.log(i); &#125;,1000); &#125;)(); &#125; 执行该代码，依旧会在for循环结束之后输出5个数字6。这是因为虽然每个延迟函数都会将IIFE每次迭代中创建的作用域封闭起来，但是IIFE创建的作用域虽然是封闭的，但只是一个空的作用域，并不能为我所用。因此，需要向该作用域中添加一些实质内容，才能为我使用。再次将代码修改为12345678for(var i=0;i&lt;=5;i++)&#123; (function()&#123; var j = i; setTimeout(function timer()&#123; console.log(j); &#125;,1000); &#125;)(); &#125; 上述代码可以正常工作，并每秒输出一个数字，数字为1~5。上述代码中，将for循环中的变量i传递至IIFE创建的封闭作用域中，会输出如期的结果。当然，上述代码也可以修改为如下所示的代码， 效果是一样的。1234567for(var i=0;i&lt;=5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j); &#125;,1000); &#125;)(i); &#125; 总结上述代码修改过程，可以发现，当使用IIFE在每次迭代时创建一个新的非空的封闭的作用域时，可以输出如期的结果。也就是说，每次迭代都需要创建一个块作用域。 JS中let声明可以用来劫持块作用域，并且在这个块作用域中声明一个变量。 本质上这是将一个块转换成一个可以被关闭的作用域。123456for(var i=0;i&lt;=5;i++)&#123; let j = i; //闭包的块作用域 setTimeout(function timer()&#123; console.log(j); //1 2 3 4 5 &#125;,1000); &#125; 上述代码中使用let声明了变量j，let创建了一个块作用域，程序输出为1~5，和用IIFE的方式效果一样。 此外，若在for循环头部中使用let声明，还会产生一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会被声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。12345for(let i=0;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i); //1 2 3 4 5 &#125;,1000); &#125; 关于this this既不指向函数自身也不指向函数的词法作用域。 当一个函数被调用时，会创建一个执行上下文（或活动记录）。这个执行上下文会包含函数在哪里被调用（调用栈），函数的调用方式，传入的参数等信息。this就是这个执行上下文的一个属性，会在函数执行的过程中用到。 this实际上是在函数调被调用时发生绑定的，并不是在编写时候绑定的，它的上下文取决于函数调用时的各种条件。this的绑定与函数声明的位置没有任何关系，只取决于函数调用的方式（调用位置或调用方法）。this 绑定规则 默认绑定 隐式绑定1234567891011function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2; foo:foo;&#125;;var bar = obj.foo; //函数别名var a = "lbs0912";bar(); // lbs0912 虽然bar是obj.foo的一个引用，但实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，故this使用了默认绑定，this.a = a = window.a (global scope)，而不是·obj.a·。 显示绑定硬绑定是显示绑定的一种。使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this。 new绑定如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。对于this绑定来说，称为new绑定。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript创建标记片段充实内容实践]]></title>
      <url>%2F2016%2F10%2F25%2FJavaScript%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0%E7%89%87%E6%AE%B5%E5%85%85%E5%AE%9E%E5%86%85%E5%AE%B9%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[前言本文主要记录了运用JavaScript创建标记片段来充实文档内容的一些实践和注意事项。 充实文档内容8.1 HTML，XHTML和HTML5对于标记而言，无论选用 HTML，XHTML，还是HTML5，都必须和DOCTYPE声明保持一致。 XHTML对标记有着更严格地要求，这样可以督促我们写出更严清晰的文档。而HTML对标签和属性的要求则没有这么严格，例如，HTML中既允许使用大写字母（如&lt;DIV&gt;）,也允许使用小写字母（如&lt;div&gt;）。 推荐使用XHTML，其优点包括 XHTML中要求所有的标签名和属性名必须使用小写字母。 XHTML中所有标签都必须闭合——对诸如&lt;img&gt;和 &lt;br&gt;标签也不例外。而HTML中允许部分标签省略结束标签——比如可以省略&lt;/p&gt;和&lt;/li&gt;标签等。为了与早期的浏览器保持兼容，应该在反斜杠字符的前面保留一个空格，例如&lt;br /&gt;。 In HTML, the &lt;br&gt; tag has no end tag.In XHTML, the&lt;br&gt; tag must be properly closed, like this: &lt;br/&gt;. 若使用XHTML，则其DOCTYPE的写法为1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 若采用HTML5方案，则只需书写1&lt;!DOCTYPE html&gt; 即可，该声明同样支持HTML和XHTML。 8.2 快捷键设置HTML中，accesskey属性可以把一个元素（如链接）与键盘上的某个特定的按键关联在一起，起到键盘快捷方式的作用。 一般来说，windows系统的浏览器中，快捷键的用法是Alt + 特定按键。Mac系统的浏览器里，快捷键的用法是Ctrl + 特定按键。 1&lt;a href="http://liubaoshuai.top" accesskey="1"&gt;My Blog&lt;/a&gt; 上述代码中，对链接绑定了快捷键。在浏览器访问中，windows下只需按下Alt + 1，就可访问该链接。 ###8.3 lastChild V.S. lastElementChild The lastChild property returns the last child node of the specified node, as a Node object. The returned node object may be an element node, a text node or a comment node. The lastElementChild property returns the last child element of the specified element. The returned node object should be an element node, ignores a text node and a comment node. The difference between lastChild and lastElementChild, is that lastChild returns the last child node as an element node, a text node or a comment node (depending on which one’s last), while lastElementChild returns the last child node as an element node (ignores text and comment nodes). — W3 School Note: Whitespace and line breaks inside elements is considered as text, and text is considered as nodes。（空格和换行符会被当做文本节点，在使用lastChild时，可能会将空格和换行符当做文本节点返回。） 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;Example list:&lt;/p&gt; &lt;ul id="myList"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Click the button to get the HTML content of the list's last child node.&lt;/p&gt; &lt;button onclick="myFunction()"&gt;Try it&lt;/button&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Whitespace inside elements is considered as text, and text is considered as nodes.&lt;/p&gt; &lt;p&gt;If you add whitespace before the closing UL element, the result will be "undefined".&lt;/p&gt; &lt;p id="demo"&gt;&lt;/p&gt; &lt;script&gt; function myFunction() &#123; var list = document.getElementById("myList").lastChild.innerHTML; document.getElementById("demo").innerHTML = list; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码中，将获取&lt;ul&gt;列表中的最后一个元素，然后将其显示出来。由于代码中&lt;/li&gt;和&lt;/ul&gt;之间有一个换行符，因此，lastChild返回的是该换行符，故最终结果会显示undefined。解决方案： 方法1：将lastChild替换为lastElementChild 方法2：去掉&lt;/li&gt;和&lt;/ul&gt;之间的换行符或空格，采用如下代码格式。1&lt;ul id=&quot;myList&quot;&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Tea&lt;/li&gt;&lt;/ul&gt; 综上案例，在使用lastChild和lastElementChild时，一定要注意返回节点的类型，注意二者之间的区别。下面是一个来自StackOverflow 的代码实例，编写者本意是每次点击按钮，将删除一个列表元素。但是由于采用lastChild时，换行符会被当做文本节点返回。因此，在第一次点击时候，只会删除换行符。在第2次，第3次……点击按钮时，才会正常删除列表元素。 12345678&lt;ul id="list"&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;li id="child"&gt;List item 4&lt;/li&gt; &lt;li&gt;List item 5&lt;/li&gt;&lt;/ul&gt;&lt;input type="button" value="Delete last"&gt; 123456document.getElementsByTagName('input')[0].onclick = function () &#123; 'use strict'; var list = document.getElementById('list'), item = list.lastChild; list.removeChild(item); window.alert("Removed");&#125;; 主要参考资料：[1] StackOverflow[2] MDN[3] W3 School 几乎所有的浏览器都支持lastChild属性，但是一些高版本浏览器才支持lastElementChild属性。 Accroding to the above figure, this lastElementChild property is unsupported prior to IE9, so the following snippet can be used to add support to IE8:12345678910// Source: https://github.com/Alhadis/Snippets/blob/master/js/polyfills/IE8-child-elements.jsif(!(&quot;lastElementChild&quot; in document.documentElement))&#123; Object.defineProperty(Element.prototype, &quot;lastElementChild&quot;, &#123; get: function()&#123; for(var nodes = this.children, n, i = nodes.length - 1; i &gt;= 0; --i) if(n = nodes[i], 1 === n.nodeType) return n; return null; &#125; &#125;);&#125; 上述代码来自Github。 也可以采用如下的方法，来实现lastElementChild的效果：在getElementsByTagName()中使用通配符*获取一个包含所有元素节点的数组（获取的是元素节点，不包括文本节点或者注释节点），然后输出改数组的最后一个元素。12345678910&lt;p&gt;Example list:&lt;/p&gt; &lt;ul id="myList"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Click the button to get the HTML content of the list's last child node.&lt;/p&gt; &lt;button onclick="myNewFunction()"&gt;Try it&lt;/button&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Whitespace inside elements is considered as text, and text is considered as nodes.&lt;/p&gt; &lt;p&gt;If you add whitespace before the closing UL element, the result will be "undefined".&lt;/p&gt; &lt;p id="demo"&gt;&lt;/p&gt; 12345678function myNewFunction() &#123; var list = document.getElementById("myList"); var childAllNodes = list.getElementsByTagName("*"); console.log(childAllNodes[childAllNodes.length-1].nodeName); //LI console.log(childAllNodes[childAllNodes.length-1].nodeType); //1 console.log(childAllNodes[childAllNodes.length-1].innerHTML); //Tea console.log(childAllNodes[childAllNodes.length-1].childNodes[0].nodeValue); //Tea &#125; 需要注意的是： parentNode.getElementsByTagName(*)获取的是一个包含所有元素节点的数组（获取的是元素节点，不包括文本节点或者注释节点） nodeName返回的节点名称都是大写，如LI，DIV等 元素节点的nodeValue值是null。因此，description.nodeValue的值为null。若要返回元素节点中的文本，需要执行element.childNodes[0].nodeValue语句。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript动态创建标记技术]]></title>
      <url>%2F2016%2F10%2F20%2FJavaScript%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[前言本篇博文记录总结了如何通过创建新元素和修改现有元素来改变网页结果。主要包括传统技术和DOM方法这两种。 动态创建标记本章节将讲述如何通过创建新元素和修改现有元素来改变网页结果。主要包括传统技术和DOM方法这两种。 传统技术： document.write() , innerHTML DOM技术： createElement, createTextNode, appendChild, insertBefore(在任何时候，标准的DOM都可以用来替代innerHTML)传统技术 document.write() 1document.write("&lt;p&gt;Demo&lt;/p&gt;"); innerHTML 123var testdiv = document.getElementById("testdiv");testdiv.innerHTML = "Div Content";testdiv.innerHTML = "&lt;p&gt;ChildNode Demo&lt;/p&gt;"; DOM技术 createElement ： 创建一个元素节点（不能创建文本节点），但是该节点并未插入DOM树中，是游历于文档之外的。 appendChild ：把新创建的节点插入到文档的DOM树中。 createTextNode： 创建一个文本节点（不能创建元素节点），但是该节点并未插入DOM树中，是游历于文档之外的。 parentNode.insertBefore(newNode,referenceNode)：将一个新节点插入到参考节点之前，这两个节点都是parentNode的子节点。1234567891011121314151617181920var parentNode = document.getElementById("content");var para = document.createElement("p");var txt1 = document.createTextNode("This is");para.appendChild(txt1); //&lt;p&gt;This is &lt;/p&gt;var emphasis = document.createElement("em");var txt2 = document.createTextNode(" my");emphasis.appendChild(txt2);para.appendChild(emphasis); //&lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; &lt;/p&gt;parentNode.appendChild(para);var txt3 = document.createTextNode(" node");para.appendChild(txt3); //&lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; node&lt;/p&gt;var head1 = document.createElement("h1");var txt4 = document.createTextNode("Head 1");head1.appendChild(txt4); //&lt;h1&gt;Head 1&lt;/h1&gt;parentNode.insertBefore(head1,para); //!! 上述代码，将创建一个如下所示的HTML文档。注意上述代码中最后一句中insertBefore的用法（将一个新节点插入到父节点中指定的子节点的前面，新插入的节点是父节点的子节点）。1234&lt;div id="content"&gt; &lt;h1&gt;Head 1&lt;/h1&gt; &lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; node&lt;/p&gt;&lt;/div&gt; insertAfter()DOM本身并没有提供insertAfter()方法，但是可以借助于insertBefore()和appendchild()方法实现该insertAfter()方法。 parentElement.insertBefore(newElement,targetElement); 12345678910function insertAfter(newElement,targetElement)&#123; var parent = targetElement.parentNode; if(parentNode.lastChild == targetElement)&#123; parent.appendChild(newElement); &#125; else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; 上述代码中，nextSibling表示下一个兄弟节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript DOM学习笔记]]></title>
      <url>%2F2016%2F10%2F08%2FJavaScript%20DOM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[前言这篇博文主要记录了学习JavaScript过程中关于DOM的部分心得与总结。 DOM学习总结 5个常用的DOM方法：getElementById,getElementsByTagName,getElementsByClassName,getAttribute和setAttribute。 getElementById()返回的是一个具有指定ID属性值的元素节点对应的对象，是一个单一对象，因此getElementById中元素Element为单数。 getElementsByTagName()和getElementsByClassName()方法返回的是对象数组，因此，Elements为复数。getElementByTagName(“*”) getElementByTagName(&quot;*&quot;)中使用*通配符，表示获取文档中的全部元素节点。通配符*必须放在用引号中，来和乘法符号区别。例如，要想知道文档中有多少个元素节点，可以使用 1var length = document.getElementByTagName("*").length; getElementByTagName(&quot;tag&quot;) 返回的是一个对象数组，具有数组的length属性，若采用typeof返回其类型，其结果为object`。若针对HTML文档 12345&lt;ul&gt; &lt;li&gt; A &lt;/li&gt; &lt;li&gt; B &lt;/li&gt; &lt;li&gt; C &lt;/li&gt;&lt;/ul&gt; 其JS代码为123456789var myArray = document.getElementsByTagName("li"); //[li,li,li]var length = myArray.length; //3for(var i=0;i&lt;length;i++)&#123; console.log(myArray[i]); // &lt;li&gt; A &lt;/li&gt; &lt;li&gt; B &lt;/li&gt; &lt;li&gt; C &lt;/li&gt;&#125;console.log(myArray); //[li,li,li]console.log(typeof myArray); //objectconsole.log(typeof myArray[0]); //object 则执行结果为 对于上述代码，即使只有一个&lt;li&gt;列表，返回的也是一个对象数组，是object对象，其length为1，其中每一个元素都是对象（这里只有一个元素）。 getElementByTagName(className1 className2)getElementByTagName(className1 className2)中，若传入多个类名称，类名成之间以空格隔开，而不是逗号隔开。 getElementById, getElementsByTagName和getElementsByClassName的组合使用getElementById,getElementsByTagName和getElementsByClassName三者间可以组合使用，共同对元素节点进行选取。例如，获取id为demo且class为content的元素节点，其代码如下所示。12var demo = document.getElementById("demo");var final = demo.getElementsByClassName("content"); getAttribute和setAttribute12345678//---&lt;div id="demo"&gt;Demo&lt;/demo&gt;//---var demo = document.getElementById("demo");console.log(demo);console.log(demo.getAttribute("id"));demo.setAttribute("id","test");console.log(demo.getAttribute("id")); 对于上述代码，使用getAttribute()可以获取元素的属性，使用setAttribute()可以对元素属性进行设置。 通过setAttribute()方法对文档做出的修改，将使得文档在浏览器窗口里的显示效果和/或行为动作发生相应的变化，但在通过浏览器的view source（查看源代码）选项去查看文档的源代码时看到的仍将是原来的属性值——也就是说，setAttribute()方法做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式：先加载文档的静态内容，再以动态方式对它们进行刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力和诱人之处：对页面内容的刷新不需要最终用户在他们的浏览器里执行页面刷新操作就可以实现。 setAttribute()并不会修改文档的物理内容，而是改变DOM树。这是因为浏览器实际显示的是DOM树的内容，在浏览器看来，DOM节点树才是文档 注意事项 getElementById()返回的是一个具有指定ID属性值的元素节点对应的对象，是一个单一对象，因此getElementById中元素Element为单数。 getElementsByTagName()和getElementsByClassName()方法返回的是对象数组，因此，Elements为复数。 getElementsByTagName()The getElementsByTagName() method returns a collection of an elements’s child elements with the specified tag name, as a NodeList object. The NodeList object represents a collection of nodes. The nodes can be accessed by index numbers. The index starts at 0. Tip: You can use the length property of the NodeList object to determine the number of child nodes with the specified tag name, then you can loop through all nodes and extract the info you want. Tip: The parametervalue “*” returns all of the element’s child elements.— W3 School 若HTML文档为1&lt;div class="demo" id="demo"&gt;Hello World&lt;/div&gt; 考虑如下代码1123// code 1var demo = document.getElementById("demo");demo.setAttribute("class", "democlass"); 上述代码1可以成功地将&lt;div&gt;的class属性值设置为democlass。这是因为getElementById()返回的是一个具有指定ID属性值的元素节点对应的对象，是一个单一对象。此时，demo为&lt;div class=&quot;demo&quot; id=&quot;demo&quot;&gt;Hello World&lt;/div&gt;。 若要用getElementsByTagName()和getElementsByClassName()方法实现上述同样的功能，需要避免如下错误，如下代码2所示。1234// code 2var demo = document.getElementsByClassName("demo");console.log(demo);demo.setAttribute("class", "democlass"); 执行上述代码2，会出现如下错误。错误原因是因为getElementsByClassName()方法返回的是对象数组，而不是一个单一的对象，即使HTML中只有一个class=&quot;demo&quot;的元素。控制台输出demo结果为[div#demo.demo, demo: div#demo.demo]，如下图所示。demo是一个对象数组，demo[0]才是&lt;div class=&quot;demo&quot; id=&quot;demo&quot;&gt;Hello World&lt;/div&gt;。 对于上述代码，进行如下修改，则可以正常修改&lt;div&gt;的class名。1234// code 2var demo0 = document.getElementsByClassName("demo")[0];console.log(demo0);demo0.setAttribute("class", "democlass"); 上述代码运行结果为 类似地，若采用getElementsByTagName()实现上述功能，仍然要注意该方法返回的是一个对象数组，而不是一个对象。12345// code 3var demo = document.getElementsByTagName("demo"); //对象数组var demo0 = demo[0]; //一个对象demo0.setAttribute("class", "democlass"); //正常demo.setAttribute("class", "democlass"); //TypeError 改变元素属性的DOM解决方案和非DOM解决方案以改变&lt;img&gt;标签的src属性为例，提供DOM解决方案和非DOM解决方案。（下例代码中whicpic为点击的&lt;a&gt;标签，将&lt;a&gt;标签的href属性值传递给&lt;img&gt;标签的src属性）1234//DOM 解决方案var source = whichpic.getAttribute("href");//获取a标签的href属性 var placeholder = document.getElementById("placeholder"); //获取img对象 placeholder.setAttribute("src",source); //属性设置 DOM解决方案中，通过getAttribute和setAttribute来进行属性的设置。而非DOM方案中，直接对属性值进行设置即可。1placeholder.src = source; 个人更推荐DOM解决方案，因为DOM方案的调用格式都相同，非DOM方案中每种属性值设置方法不一样，需要去识记。此外，DOM方案对于任何一种标记语言都适用，而非DOM方案则不具有普适性。 ###3.7 标签中阻止点击默认行为的发生123456789&lt;ul&gt; &lt;li&gt; &lt;a href="images/fireworks.jpg" title="A fireworks display" onclick="showPic(this); return false;"&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="images/coffee.jpg" title="A cup of black coffee" onclick="showPic(this); return false;"&gt;Coffee&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 对于上述代码，点击对应的&lt;a&gt;标签，会调用对应的事件处理函数showPic(this)。如果不加上return false或者return true，则会执行&lt;a&gt;标签被点击后的默认行为（此处为在一个新的窗口中显示图片）。为了阻止默认行为的发生，可以对onclick事件给出一个返回值：return true表示这个链接已经被点击了，则会执行默认的行为；return false表示这个链接没有被点击，则不会触发默认的行为。 ###3.8 其他 childNodes在一棵节点树上，childNodes属性可以用来获取任何一个元素的所有子元素，它是一个包含这个元素全部子元素的数组。1element.childNodes 例如，获取body元素的全部子元素，其方法为123var body_elemengt = document.getElementsByTagName(&quot;body&quot;)[0]; //[0] 不要忘记body_element.childNodes; //子元素body_element.childNodes.length; //返回子元素个数 nodeTypenode.nodeType可以获取节点的节点属性，其返回值是一个数字，共12种取值，最常用的返回值有3种。（1）元素节点的nodeType属性值 = 1（2）属性节点的nodeType属性值 = 2（3）文本节点的nodeType属性值 = 3 例如，对于1&lt;p title="a gentle reminder"&gt; Don't forget to buy this stuff.&lt;/p&gt; ，其元素节点为p，其属性节点为title=&quot;a gentle reminder&quot;，其文本节点为Don&#39;t forget to buy this stuff.。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="demo" id="demo"&gt;Hello World&lt;/div&gt; &lt;script&gt; console.log(document.getElementsByTagName("body")[0].childNodes.length); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 执行上述代码，控制台输出body的子元素个数为4：1个元素节点div，1个属性节点(id和class属性值算作一个节点)，1个文本节点，1个元素节点&lt;script&gt;。即element.childNodes.length会统计所有种类的节点个数，而不仅仅是元素节点个数。若想统计元素节点个数，可以根据nodeType值进行判断。123456789var myChildNodes = document.getElementsByTagName("body")[0].childNodes;var length = myChildNodes.length;var count = 0;for(var i=0;i&lt;length;i++)&#123; if(myChildNodes[i].nodeType == 1) &#123; count++; &#125;&#125;console.log(count); //2 1个元素节点div 1个元素节点`&lt;script&gt;` nodeValue The nodeValue property sets or returns the node value of the specified node. If the node is an element node, the nodeValue property will return null.Note: If you want to return the text of an element, remember that text is always inside a Text node, and you will have to return the Text node’s node value (element.childNodes[0].nodeValue). — W3 School HTML DOM nodeValue Property 1&lt;p id=&quot;description&quot;&gt;Choose an image&lt;/p&gt; 对于上述节点，执行如下代码。123var description = document.getElementById("description");alert(description.nodeValue); //nullalert(description.childNodes[0].nodeValue); //Choose an image 元素节点的nodeValue值是null。因此，description.nodeValue的值为null。若要返回元素节点中的文本，需要执行element.childNodes[0].nodeValue语句。 firstChild， lastChild 12element.childNodes[0] = element.firstChild;element.childNodes[element.childNodes.length-1] = element.lastChild; nodeNameGo to W3 School website for more information. nodeName可以返回节点的名称，注意返回的字符串都是大写的。12document.getElementsByTagName("div").nodeName == "div"; //falsedocument.getElementsByTagName("div").nodeName == "DIV"; //true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学校网页实例练习总结]]></title>
      <url>%2F2016%2F09%2F27%2F%E5%AD%A6%E6%A0%A1%E7%BD%91%E9%A1%B5%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作学校网页demo过程中的一些心得和技巧。 心得与技巧html/css设置盒子模型中文字垂直居中方法我们在设置css样式时，经常需要在如div中填写很多文字，而且大部分时候为了美观，都需要使文字在包裹元素中垂直居中，如本demo中的导航条里面的文字一样，这时我们可以通过设置文字行高line-height与width相同即可，这是非常常用的一个小技巧。如下所示：123456789.title &#123; height: 35px; border-bottom: 2px solid #E8E8E8; font-size: 14px; font-family: "微软雅黑"; line-height: 35px; font-weight: bold; color: #786F66;&#125; 背景图片设置技巧设置背景图片，很多时候不是给个background-image属性再加上一个图片的url地址就可以了，我们需要较为详细了解一下css常用的background属性。 以一个例子说明常用的背景属性：1234body &#123; background: #00FF00 url(bgimage.gif) no-repeat fixed center; &#125; 按照顺序，这些简写属性分别代表background-color、background-image、background-repeat、background-attachment和background-position。值得说明的是，background-repeat是代表如何重复背景图片，即可以选择默认在水平和垂直方向上重复repeat，仅在水平方向上重复repeat-x，仅在垂直方向上重复repeat-Y和不重复no-repeat等。background-position规定背景图像的位置。background-attachment规定背景图像是否固定或者随着页面的其余部分滚动。具体关于background属性的详细介绍参看css background属性。 在这demo中也利用了这个属性设置了导航条的背景：1234.nav_left &#123; width: 10px; background: url(../images/nav_left.jpg) no-repeat;&#125; 搜索栏中的放大镜 小图标也是用这种方法设置的： 12345.search_text &#123; ... background: url(../images/search.jpg) no-repeat right center; ...&#125; 这里添加一个小技巧，为了使搜索框里面的字不超过搜索小图标，可以给搜索框设置右填充，即内边距即可。 同理，还可以利用这种方法设置项目符号，如此demo中最新动态下面的项目符号，用背景图片的方式，并设置左内边距即可： 123456789.news_list li &#123; background: url(../images/list.jpg) no-repeat; list-style-type: none; padding-left: 10px; margin: 8px; border-bottom: 1px dotted #CCC; height: 17px; line-height: 17px;&#125; 如果设置list-style-image属性也可以达到类似的效果。 设置图片和文字对齐有时候在行间文字后面添加一个小图片的时候，如果不加任何设置，我们会发现文字和图片是错行的，这时我们可以利用vertical-align属性设置图片和文字对齐，如下所示：1234.logo_right img &#123; vertical-align: middle; margin-right: 10px;&#125; 此demo中为了使联系电话文字与旁边电话小图标在同一水平线上对齐，利用这个属性设置为middle达到效果。 a标签伪类设置CSS 伪类用于向某些选择器添加特殊的效果。其中a标签常用的四种锚伪类如下所示：1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 这里在设置的时候有个需要特别注意的地方，即在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，a:active 必须被置于 a:hover 之后，才是有效的。 本demo中，导航条的a标签样式设置为如下形式 ，也是非常常用的一种格式： 12345678910.nav_mid a:link, .nav_mid a:visited &#123; font-size: 16px; color: #FFF; text-decoration: none;&#125;.nav_mid a:hover, .nav_mid a:active &#123; font-size: 16px; color: #FF0; text-decoration: none;&#125; li标签中a和span标签错位问题在正常设置最新动态下面的每一条动态标题和时间的时候，对标题用a标签实现，对对应的时间用span标签实现，并设置 span标签右浮动，然后按照正常的顺序书写html结构，但是在ie浏览器下可能会出现标题和时间不对齐错位的情况，这时解决办法是将a和span标签在li标签中的书写顺序进行调换： 12345678&lt;div class="news_list"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;2016-07-20&lt;/span&gt; &lt;a href="news.html"&gt;2016年研究生管理信息系统培训会举行&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;2016-08-04&lt;/span&gt;&lt;a href="news.html"&gt;九名交大学子远赴丹麦参加创新实践夏令营&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;2016-09-08&lt;/span&gt;&lt;a href="news.html"&gt;我校10名博士生赴瑞典荷兰参加SEEEP暑期学校&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;2016-10-17&lt;/span&gt;&lt;a href="news.html" title="aa"&gt;2016年国际研究生招生总结交流会​召开&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 插入视频的方法可以利用html中的embed标签实现，本demo中采用的是优酷中的视频，在视频下方‘分享给朋友’处点击下拉键，可以看到html代码选项，直接复制并修改相应属性即可： 123&lt;p class="video_content"&gt; &lt;embed src='http://player.youku.com/player.php/sid/XNDA4MTkxNzM2/v.swf' allowFullScreen='true' quality='high' width='220' height='140' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt; &lt;/p&gt; 底部区域ul和li嵌套实现为了实现底部区域分类列项的形式，可以通过ul标签和li标签的嵌套方式实现，如下所示： 1234567891011121314151617&lt;div class="copyright_content"&gt; &lt;ul&gt; &lt;li&gt;报名申请 &lt;ul&gt; &lt;li&gt;硕士研究生&lt;/li&gt; ...... &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;管理信息系统 &lt;ul&gt; &lt;li&gt;学生、教师、导师&lt;/li&gt; ...... &lt;/ul&gt; &lt;/li&gt; ...... &lt;/ul&gt; &lt;/div&gt; 为了达到理想的效果，这里在设置css样式的时候有需要注意的地方，在给li标签设置左浮动的同时，还需要给它设置一个固定的宽度，大小即为总外层div大小除以分成的列数，这样的目的是使嵌套的子li部分因为宽度限制而按照列排列而不是行排列，设置如下所示： 12345678.copyright_content li &#123; list-style-type: none; float: left; width: 200px; text-align: center; background: url(../images/line.png) no-repeat right center; ......&#125; 同样，列与列之间的竖线也是通过前面所述的背景图片方式设置的。而文字的居中对齐应用text-align: center实现。 JS设置焦点图制作在这个demo中上部有一块很大的焦点图区域，可以实现图片的轮播，给网站增加动态元素，避免使界面显得过于单调。这里主要使用myFocus插件来实现这个功能。 首先进入myFocus网站下载插件文件，然后在html文件的头部引入这个js文件： 1&lt;script type="text/javascript" src="js/myfocus-2.0.1.min.js" charset="utf-8"&gt;&lt;/script&gt; 之后在html文件中需要放置焦点图的地方添加结构： 123456789101112&lt;div class="ad"&gt; &lt;div id="boxID"&gt; &lt;div class="loading"&gt;&lt;img src="images/loading.gif" alt="请稍候..." /&gt;&lt;/div&gt; &lt;div class="pic"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/ad2.jpg" thumb="" alt="" text="" /&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/ad3.jpg" thumb="" alt="" text="" /&gt;&lt;/a&gt;&lt;/li&gt; ...... &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 这里需要注意以下几个问题： 焦点图初始化的ID与图片列表最外层的ID一致，这里的ID设置为‘boxID’。 图片列表外面，包裹一个class为pic的div。 为了使显示效果更友好，可以添加loading图片，使得在加载时显示出等待载入的效果。同时为了使ad的溢出部分隐藏，可以使用overflow属性，并设置为hidden即可，如下所示： 12345.ad &#123; height: 320px; margin-top: 5px; overflow: hidden;&#125; 最后在html文件的头部区域，还需要对myFocus进行属性的相关配置： 123456789myFocus.set(&#123; id:'boxID',//焦点图盒子ID pattern:'mF_fancy',//风格应用的名称 time:3,//切换时间间隔(秒) trigger:'click',//触发切换模式:'click'(点击)/'mouseover'(悬停) width:1000,//设置图片区域宽度(像素) height:310,//设置图片区域高度(像素) txtHeight:'default'//文字层高度设置(像素),'default'为默认高度，0为隐藏&#125;); 更详细配置请参考myFocus教程。 心得补充与小技巧 设置min-height可以使里面填充的内容超过包裹div元素的时候可以自动撑开，这里需要注意的一点是如果还有外层div包裹，也要一并设置这个属性，防止内容继续超过更外一层的div。(此属性ie6不支持，为了兼容，需要hack，即添加_height属性) 在设置间距的时候，得根据实际情况选择是使用margin还是padding来达到效果。如果其他条件相同，在可能会影响外界整体布局的情况下，推荐使用padding。 如果想设置a标签效果为鼠标放上去的时候的背景颜色变化是整个区域而不仅仅是字的颜色，则可以把display属性设置为block。同时考虑到兼容性问题，a标签高度在不同浏览器可能不一样，尤其背景填充的时候，这时可以考虑把它设置为内联块状元素来解决问题。 有时为了想达到包含文字的div的宽度大小是随着文字多少而不同的效果，这时可以只设置border而不设置宽度width即可，宽度通过内填充来撑开。总结在制作这个实例的过程中，虽然简单，但是可以锻炼关于基本html/css和div布局的基础，同时关注很多的细节处理，就能在实际的案例中可以学到很多小技巧和经验，积少成多，为以后打下基础。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github+Hexo搭建独立域名的静态博客]]></title>
      <url>%2F2016%2F09%2F20%2FGithub%2BHexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%9F%9F%E5%90%8D%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[1. 前言查阅了很多资料，踩了很多的坑之后，一个拥有独立域名的静态博客终于搭建完成。本文主要叙述了利用github和hexo搭建博客的过程和心得，一方面希望给同样想搭建独立域名的静态博客的朋友一些启发与引导，另一方面也是给自己的个人笔记，记录下来以后不会遗忘。本文主要针对windows用户。 2. Github和Hexo介绍GitHub 是现在非常火热的一个面向开源及私有软件项目的托管平台，这里我们使用github pages服务搭建博客，使用这个服务的优势在于全是静态文件，访问速度很快，而且免费方便，不需要自己管理服务器和后台，可以将精力都放在博文的撰写上，同时还可以绑定自己的个人域名等。具体参考github官方网站。 Hexo是一款基于Node.js的静态博客框架，它的优势主要在于简便和快速，它支持多进程，支持GitHub Flavored Markdown和所有Octopress的插件，同时还拥有良好的扩展性，支持EJS、Swig和Stylus，并通过插件支持Haml、Jade和Less。具体参考hexo官方网站。 3. 搭建过程3.1 安装Git进入git官方网站下载并安装git，按照操作提示走就可以了。 3.2 安装Node.js进入node.js官方网站下载并安装node.js，步骤也很简单，按照提示走即可，这里需要注意的是，安装完之后最好将电脑重启一下。 3.3 安装和配置Hexo当电脑上成功安装了git和node.js之后，下面就可以通过命令行对hexo进行安装和配置。首先在任意地方点击鼠标右键，选择Git Bash这个选项，然后输入以下命令完成hexo的安装。1$ npm install hexo-cli -g 之后选择某个目录放置创建hexo的文件夹，如F:\hexo，然后进入此文件夹，点击鼠标右键，选择Git Bash这个选项，输入以下命令，实现hexo的初始化配置。12$ hexo init #hexo初始化$ npm install #安装依赖包 通过hexo -v命令可以查看安装的hexo的版本号，以此验证是否安装成功。这时继续在F:\hexo中执行以下命令：12$ hexo g #hexo generate 生成静态页面$ hexo s #hexo server 启动本地服务 在浏览器中打开http://localhost:4000，就可以看到hexo博客框架默认主题的效果了，在命令行中输入ctrl+c可以退出本地预览。 3.4 补充说明在生成静态页面和启动本地服务的时候如果出现报错信息：hexo:ERROR Deployer not found: git，则需要执行以下命令：1$ npm install hexo-deployer-git --save 而如果出现ERROR Plugin load failed: hexo-server的报错信息，则需要执行以下命令：1$ sudo npm install hexo-server 之后再按照上述命令启动本地服务即可看到默认主题的hexo页面了。 这里再补充介绍一下hexo的常用命令。12345678910111213hexo new "My New Post" # create a new posthexo server # run hexo serverhexo generate # Generate static fileshexo deploy # Deploy to remote siteshexo n #hexo new的简写hexo s # hexo server的简写hexo g # hexo generate的简写hexo d # hexo deploy的简写hexo clean # 清楚缓存文件hexo -v # 查看hexo版本hexo help # 查看hexo帮助hexo d -g # 生成部署 组合命令hexo s -g # 生成预览 组合命令 3.5 静态页面部署到Github上3.5.1 创建Github仓库现在我们还只能在本地查看，下面我们将我们的静态博客部署到github上。首先注册自己的github账号，记住自己的用户名、邮箱和密码等。然后在github的个人页面里，选择Repositories并点击New新建一个仓库repositories，填上仓库名Repository name，注意这里的仓库名必须是youname.github.io的形式，即你前面注册的用户名加上.github.io。建立完自己的仓库之后可以通过Settings里面的GitHub Page预览github提供的默认效果页面，网址就是https://youname.github.io/。 3.5.2 配置SSH如果github刚注册还未配置SSH，还需要先配置SSH。SSH 为 Secure Shell 的缩写，是建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。具体的配置方法参考史上最全github使用方法:github入门到精通 3.5.3 部署本地文件到Github上打开本地创建的hexo文件夹，找到_config.yml文件并打开它，这里推荐使用Sublime或Notepad++ 编辑器打开，进行如下修改：1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 这里有两点需要注意，一个是这里的yourname还是前面说的改成注册github时的用户名，另一个是hexo的配置文件中任何’:’后面都是带一个空格的。修改之后保存，执行以下命令：123hexo clean hexo generate #or hexo ghexo deploy #or hexo d 之后打开https://yourname.github.io/看到静态博客页面，说明静态博客已成功部署到了github上。 3.6 修改Hexo配置文件在hexo中主要有两个非常重要的配置文件_config.yml，一个是站点配置文件，一个是主题配置文件。 3.6.1 站点配置文件首先来说一下站点配置文件的修改。站点配置文件位于hexo的根目录下，找到并打开它，主要需要修改的地方如下所示：123456title: Yinzhehao blog #博客名subtitle: Try my best #副标题description: 饮水思源 止于至善 #用于搜索author: Yin Zhehao #作者language: zh-Hans #语言timezone: #时区 12per_page: 10 #每页显示的文章数，0表示不分页pagination_dir: page 123plugins:- hexo-generator-feedtheme: next #使用的主题，即：hexo根目录themes文件夹下的主题文件夹名 1234feed: #配置rss type: atom path: atom.xml limit: 20 以上是站点配置文件中常用的一些需要修改的地方，大家根据自己的意愿进行相应的修改即可。 3.6.2 主题配置文件hexo官方提供了很多主题供大家选择，参见hexo主题主题具体使用方法就是点击自己想要的主题，进入该主题在github中的Repository，然后用git命令将主题clone到本地hexo根目录中themes文件夹下，并将上面站点主题配置里的theme名字改为下载的主题的文件夹名即可。而主题配置文件就位于下载的主题的文件夹里面。 以本博客使用的next主题为例，此主题的github仓库地址是hexo-theme-next，clone下来解压到hexo根目录中themes文件夹下后，将站点主题配置里的theme名字改为next，然后参考Next使用文档完成详细的主题配置，包括主题设定、集成第三方服务、添加标签和分类页面等等。 3.7 发表文章为了检验上面的hexo配置效果，也为以后撰写博客做准备，我们先小试牛刀，发表一篇文章。首先，在hexo根目录下执行以下命令：1$ hexo new &quot;your-post-name&quot; #双引号中是生成的md文件名 然后在F:\hexo\source\_post中打开your-post-name.md文件，同理推荐采用Sublime或Notepad++ 编辑器，并使用Markdown语法进行博客的撰写，Markdown语法参考Markdown语法说明。基本结构如下所示：1234567---title: your-post-name #文章标题date: 2016-09-20 15:57:06 #发表日期tags: [github,hexo,blog] #文章标签categories: blog #文章分类---#下面是正文部分 这里有个小技巧，如果文章整体较长或者作者不想游客一开始就观看到全部内容，可以选择写一段内容简介后，加上&lt;!--more--&gt;，这样之前的内容会显示，而之后的内容会被隐藏，显示Read more或阅读全文，当游客点击之后就能看到全部内容。 之后使用如下命令进行本地预览：12hexo cleanhexo s -g 使用如下命令部署到github上：12hexo cleanhexo d -g 最后打开浏览器登上https://yourname.github.io/就可以看到自己漂亮的静态博客了。 3.8 独立域名配置现在虽然可以访问个人博客了，但是用的域名还是https://yourname.github.io/，为了可以使用独立域名访问自己的个人博客，还需要进行一些设置。 3.8.1 申请与购买域名我是在阿里云进行域名的申请与购买的，大家可以在阿里云或其他地方申请与购买域名，根据不同的后缀价格不同。 3.8.2 DNS解析拥有域名之后还需要进行DNS解析，这里推荐使用DNSPod进行解析，具体方法参考如何使用dnspod解析域名，其中，需要向你的DNS 配置中添加 3 条记录：@ | A | 192.30.252.153@ | A | 192.30.252.154www | CNAME | username.github.io.其中username就是你自己的github用户名。DNS解析需要一段时间，需要耐心等待一会儿。 这里有个需要注意的问题，如果你是在阿里云申请购买的域名，而在DNSPod进行解析的时候，需要回到阿里云，将个人基本信息里面的DNS服务器修改为如下值：f1g1ns1.dnspod.netf1g1ns2.dnspod.net否则无法解析成功。 3.8.3 配置CNAME文件在hexo的根目录的source文件夹里手动添加一个名为CNAME的文件，文件名必须大写且一模一样，打开这个文件，并写上你的域名，且只能包含一个顶级域名，之后保存。然后像前面一样进行本地预览和部署即可。这时在浏览器中输入你的个人域名也可以访问你的静态博客啦。 4. 总结至此，利用Github和Hexo已经搭建出具有独立域名的静态博客了，而且具有了博客的一些基本功能。大家在搭建过程中如果遇到什么问题，欢迎一起探讨解决，也欢迎大家能对本文中存在的问题和不足进行批评指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown插入图片的方法和技巧]]></title>
      <url>%2F2016%2F09%2F18%2FMarkdown%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有 很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown,完全采用Markdown编辑器的博客平台有Ghost和Typecho。本人在自学过程中，感受到了Markdown的简洁性和广泛的应用，同时在实际应用中需要插入图片的地方几乎无处不在，为了使初学者可以更快找到适合自己的方法，本文对Markdown插入图片的方法和技巧进行了总结。 Markdown插入图片的方法方法一 行内式插入图片行内式语法结构：![Alt text](/path/to/img.png)或![Alt text](/path/to/img.png &quot;Optional title&quot;) 说明：Alt text中填写的是如果图片显示不出来时显示的文字；/path/to/img.png为图片所在的路径，可以是本地图片路径，也可以是网上图片路径；Optional title中填写的是你将鼠标放到图片上之后浮现出来的小框中的内容，是可选的。 方法二 参考式插入图片参考式语法结构：![Alt text][id] 说明：Alt text中填写的是如果图片显示不出来时显示的文字；id是图片参考的名称，而且此id需要预先定义。 id预先定义:[id]: url/to/image &quot;Optional title attribute&quot; 说明：/path/to/img.png为图片所在的路径，可以是本地图片路径，也可以是网上图片路径；Optional title中填写的是你将鼠标放到图片上之后浮现出来的小框中的内容，是可选的。 方法一和方法二本质上是相同的，只是语法的顺序和写法有些区别，但是都不支持更改图片的大小。 方法三 &lt;image&gt;标签插入图片 &lt;image&gt;标签格式写法：&lt;img src=&quot;/path/to/img.png&quot; width = &quot;宽度&quot; height = &quot;高度&quot; alt=&quot;图片名称&quot; /&gt; 说明：/path/to/img.png为图片所在的路径，可以是本地图片路径，也可以是网上图片路径；width后面填的是希望设置的图片宽度；height后面填的是希望设置的图片高度；alt后面填写的是图片的名称。 方法三是直接利用html的 &lt;image&gt;标签来插入图片，它最大的优势在于可以指定图片的大小。 Markdown插入图片的技巧技巧一 使用Mou编辑器来更改图片大小要想改变图片的大小，除了用上面方法三的方法之外，还可以利用Mou编辑器达到目的。语法结构如下：![Alt text](/path/to/img.png =width*height)其实总体语法结构是与方法一相似的，就是后面加上了=width*height,这里就写上所想要设置的宽度和高度即可。这里需要注意的是=前面还有一个空格，不要漏掉。 技巧二 使图片居中显示方法很简单，利用html标签中的&lt;div&gt;即可做到。具体操作是在外面包围div标签并设置align属性为center即可:123&lt;div align="center"&gt; ...&lt;/div&gt; 技巧三 用网址路径插入图片用本地路径有时会出现各种各样的问题，而如果用网址路径相对而言就不会出错，这里主要推荐两种方法： a、首先找一个类似于CloudApp、Droplr的网络分享软件，然后把图片放进去，生成一个网址，最后把这个网址复制到markdown前面方法中提到的/path/to/img.png中即可。 b、通过github储存图片来达到目的。首先将需要的照片放到本地的git仓库中，并提交和发布到github上面，然后访问自己的github，找到那张图片，打开图片，选择Raw按钮，这时你会看到一个页面只有那张图片，这时将此链接地址复制下来，最后把这个网址复制到markdown前面方法中提到的/path/to/img.png中即可。 参考资料 1. 一分钟学会Markdown语法 2. Markdown 语法说明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[中秋，继续前行]]></title>
      <url>%2F2016%2F09%2F15%2F%E4%B8%AD%E7%A7%8B%E6%80%9D%E4%B9%A1%2F</url>
      <content type="text"><![CDATA[2016年9月15日，是中秋节，也是我拥有自己第一个独立域名博客的日子。以前虽说也有记录和总结自己学习过程的心得成果的习惯，不过还是第一次可以在自己独立域名的博客上写博文，后面我也将抽空逐渐将以前的很多学习笔记和总结等整理到这个博客中来，同时自己也将继续不断地学习和充实自己，中秋，继续前行！兴奋之余，本想叙述一下创建这个独立博客过程中的种种艰辛以及记录创建博客的方法心得，却不知为何，心中涌出一股惆怅，哦，想家了。 明月几时有？把酒问青天。不知天上宫阙，今夕是何年？我欲乘风归去，又恐琼楼玉宇，高处不胜寒！起舞弄清影，何似在人间？转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。————《水调歌头》 耳边响起这首熟悉的歌曲，想起自己作为在外求学的游子，今年又不能回去和父母团圆，能做的也只是打一个电话，道一句问候，报一声平安。不觉想起那些年故乡的明月，月色如水，天地一清，家人团聚，一切都是那么的温馨美好。或许就像某人说得那样：再也没有那么好吃的月饼了，再也没有那么纯净的明月了。 海内存知己，天涯若比邻。愿天下有情人，终成眷属。愿天下的父母，身体健康。祝天下芸芸众生，中秋快乐！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F09%2F15%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
