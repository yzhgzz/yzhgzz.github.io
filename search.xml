<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JS惰性载入函数]]></title>
      <url>%2F2017%2F03%2F14%2FJS%E6%83%B0%E6%80%A7%E8%BD%BD%E5%85%A5%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[[TOC] 前言本博文主要针对javascript中的惰性载入函数的优化技巧进行总结。 应用背景尽可能地对浏览器执行脚本的效率和性能问题进行优化是JS一个永恒不变的话题，而惰性载入函数的实现就是针对一些问题有效的解决办法。那到底什么是惰性载入函数以及场景下适合使用此种方法呢？首先先举个例子来抛出这个问题的应用背景。 我们知道Ajax的核心技术是XMLHttpRequest对象，而创建XMLHttpRequest对象需要考虑到浏览器的兼容问题，所以我们需要通过对象检测的办法创建下面的createXHR()函数来实现跨浏览器创建： 123456789101112131415161718192021function createXHR() &#123; if (typeof XMLHttpRequest != "undefined") &#123; return new XMLHttpRequest(); &#125; else if (typeof ActiveXObject != "undefined") &#123; if (typeof arguments.callee.activeXString != "string") &#123; var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"]; for (var i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; new ActiveXObect(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex) &#123; //跳过 &#125; &#125; &#125; return new ActiveXObect(arguments.callee.activeXString); &#125; else &#123; throw new Error("No XHR object available."); &#125;&#125; 我们观察这个函数可以发现，因为需要对浏览器所支持的能力仔细检查，所以会出现大量if语句，不过由于是考虑到浏览器兼容问题，也无法避免，但是考虑到在某个浏览器中每次调用createXHR()函数的时候都会重复检测一遍就完全没有必要了，因为第一次调用我们就可以确定这个浏览器对XMLHttpRequest对象的支持情况，后面的多次检测显得多余，可以减少if语句的重复执行时间，优化执行效率和性能。这时我们可以通过惰性载入函数的技巧来实现。 惰性载入函数技巧惰性载入的核心思想就是使得函数执行的分支仅会发生一次，之后调用函数时，直接进入所支持的分支代码。下面介绍两种实现惰性载入的方法。 函数被调用时再处理在第一次调用的过程中，该函数会覆盖为另外一个按合适方式执行的函数，这样任何对原函数的调用都不用再经过执行的分支了。如对上面的问题使用惰性载入的这种方法：12345678910111213141516171819202122232425262728function createXHR() &#123; if (typeof XMLHttpRequest != "undefined") &#123; createXHR = function () &#123; return new XMLHttpRequest(); &#125; &#125; else if (typeof ActiveXObject != "undefined") &#123; createXHR = function () &#123; if (typeof arguments.callee.activeXString != "string") &#123; var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"]; for (var i = 0, len = versions.length; i &lt; len; i++) &#123; try &#123; var xhr = new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; return xhr; &#125; catch (ex) &#123; // skip &#125; &#125; &#125; return new ActiveXObect(arguments.callee.activeXString); &#125; &#125; else &#123; createXHR = function () &#123; throw new Error("No XHR object available."); &#125;; &#125; return createXHR();&#125; 在这个惰性载入的createXHR()中，if语句的每一个分支都会为createXHR变量赋值，有效覆盖了原有的函数。最后一步便是调用新赋值的函数。所以初始的包含很多if语句的createXHR()函数只会调用一次，而后面每次调用的createXHR()都是第一次判断好之后返回覆盖的新的createXHR()函数，相当于直接调用分配的函数，就不用再次调用if语句了。 声明函数时指定适当的函数12345678910111213141516171819202122232425262728293031var createXHR = (function()&#123; if (typeof XMLHttpRequest != "undefined")&#123; return function()&#123; return new XMLHttpRequest(); &#125;; &#125; else if (typeof ActiveXObject != "undefined")&#123; return function()&#123; if (typeof arguments.callee.activeXString != "string")&#123; var versions = ["MSXML2.XMLHttp.6.0", "MSXML2.XMLHttp.3.0", "MSXML2.XMLHttp"], i, len; for (i=0,len=versions.length; i &lt; len; i++)&#123; try &#123; new ActiveXObject(versions[i]); arguments.callee.activeXString = versions[i]; break; &#125; catch (ex)&#123; //skip &#125; &#125; &#125; return new ActiveXObject(arguments.callee.activeXString); &#125;; &#125; else &#123; return function()&#123; throw new Error("No XHR object available."); &#125;; &#125; &#125;)(); 这个方法的核心就是创建了一个匿名、自执行的函数，这样就可以看做是把上面的过程挪到了代码首次加载的时候，这样甚至在第一次调用函数的时候都不会损失性能，因为这个检测在代码加载的时候就已经完成了，其实本质逻辑和上面那个方法是一样的。 优点 提高代码的执行效率，虽然第一次调用该函数会因为额外的第二个函数调用而损失一些性能，但是在所有后续的调用避免了重复检测，总体来说提高了效率。 要执行的适当代码只有当实际调用函数时才进行。某些JavaScript库一开始就根据浏览器功能或者怪癖执行很多代码分支，将所有东西先设置好，而惰性载入则将这些计算尽可能地推迟，保证了相应的功能实现同时也不影响初始脚本的执行时间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS跨域问题总结]]></title>
      <url>%2F2017%2F03%2F11%2FJS%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言本博文主要针对javascript中的跨域问题和常见的几种跨域方法进行总结。 同源策略同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。 定义与解释现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。同源策略限制了不同源之间的交互，这里需要注意的是，同源策略限制是通过js在不同的域之间进行数据传输或通信，防止某个文档或脚本从多个不同源装载。比如用ajax向一个不同的域请求数据，或者通过js获取页面中不同域的框架中(iframe)的数据。而下面的情况是不受同源策略限制的： 页面中的链接，重定向以及表单提交。 跨域资源嵌入如&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;，&lt;img&gt;，&lt;link&gt;，&lt;iframe&gt;等，但是Javascript不能读写加载的内容。 举例分析前面提到的域名，协议，端口相同有一个不同都无法通信，如以http://www.foo.com/js/a.js为例， http://www.foo.com/js/b.js 可以， 协议、域名、端口都相同；http://www.foo.com:8888/js/b.js 不可以，协议、域名相同，但端口不同；http://www.foo.com/js/b.js不可以， 主机、域名相同，但协议不同 ；http://www.bar.com/js/b.js不可以，协议、端口相同，但域名不同；http://foo.com/js/b.js不可以，协议、端口相同，主域名相同，但子域名不同 (如google. com是一级域名或顶级域名；mail.google. com 是二级域名；250.mail.google. com 是三级域名；mail.google.com和250.mail.google.com统称为子域名等)。 使用原因说了这么多，那为什么要有这个同源限制呢？举个例子大家就懂了，比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 跨域问题我们知道，通过XHR来实现Ajax通信一个主要限制就是上面提到的跨域安全问题，默认情况下XHR对象只能访问同域资源，而有时我们是需要实现合理的跨域请求来开发浏览器应用程序等，所以我们需要了解一些前端解决跨域问题的技术与方法。这里需要提前说明两个问题：1、这些方法不能处理协议和端口造成的跨域问题。2、这些方法不会去判断相同的ip地址对应着两个域或两个域是否在同一个ip上的问题。 CORS方法CORS(Cross-Origin Resource Sharing，跨源资源共享)定义了访问跨源资源时，浏览器与服务器的沟通方法。主要思想就是使用自定义的http头部让浏览器与服务器沟通，从而决定请求或响应是成功还是失败。 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。具体过程就是浏览器发送请求时附加一个origin头部信息并包含请求页面的协议、域名和端口等源信息，如：1Origin： http://www.baidu.com 如果服务器认可这个请求，就在Access-Control-Allow-Origin头部中回发相同的源信息： 1Access-Control-Allow-Origin：http://www.baidu.com 最后浏览器检测到这个头部并匹配好源信息正确，就可以处理请求了。这里请求和响应都不包含cookie信息。 iE对CORS的实现主要是运用XDR对象，它与XHR对象的不同之处在于： cookie不会随请求发送，也不会随相应返回。 只能设置请求头部的Content-Type字段。 不能访问响应头部信息。 只支持GET和POST请求。 好处在于是CSRF(跨站点请求伪造)和XSS(跨站点脚本)的问题得到缓解。使用方法：创建XDomainRequest的实例，调用open()和send()方法，请求都是异步执行，请求返回会触发load事件，响应数据会保存在responseText属性中： 1234567var xdr = new XDomainRequest();xdr.onload = function()&#123; console.log(xdr.responseText);&#125;xdr.open('get', 'http://www.baidu.com');......xdr.send(null); 如果失败会触发onerror事件处理程序。而在请求前可以调用abort()方法来终止请求。而为支持post请求，提供contentType属性来表示发送数据的格式： 1xdr.contentType="application/x-www-form-urlencoded"; 这个属性也是通过XDR对象影响头部信息的唯一方式。 其他浏览器对CORS的实现要请求在另一个域中的资源，使用标准的XHR对象并在open()方法中传入绝对URL即可： 1234567891011var xhr = new XMLHttpRequest();xhr.onreadystatechange = function () &#123; if(xhr.readyState == 4)&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 304 || xhr.status == 304)&#123; console.log(xhr.responseText); &#125; &#125;&#125;xhr.open('get', 'http://www.baidu.com');......xhr.send(null); 这里就可以使用status和statusText属性，还支持同步请求。跨域XHR也有相应的限制： 不能使用setRequestHeader()设置自定义头部 不能发送和接收cookie。 调用getAllResponseHeaders()方法总会返回空字符串。这里需要注意的一点：无论同源请求还是跨源请求使用的都是相同的接口，所以对于本地资源最好使用相对URL，而访问远程资源时再使用绝对URL，可以消除歧义，防止出现限制访问头部或本地cookie信息等问题。 JSONP方法JSONP(JSON with padding)，是被包含在函数调用里的JSON。组成部分： 回调函数：相应到来时页面中调用的函数。 数据：传入回调函数中的JSON数据。它的实现原理就是利用动态&lt;script&gt;元素，因为我们知道在页面上引入不同域上的js脚本文件是可以的，&lt;script&gt;元素有能力不受限制地从其他域加载资源。举个例子： 123456function handleResponse(response)&#123; console.log('The responsed data is: '+response.data);&#125;var script = document.createElement('script');script.src = 'http://www.baidu.com/json/?callback=handleResponse';document.body.insertBefore(script, document.body.firstChild); 这里handleResponse就是回调函数，而response就是其中的JSON数据。当我们通过script标签请求时，后台就会根据相应的参数(json,handleResponse)，来生成相应的json数(handleResponse({“data”: “content”}))，最后这个返回的json数据(代码)就会被放在当前js文件中被执行，至此跨域通信完成。 如果用jQuery来完成，可以通过封装好的方法实现，如： 12345&lt;script&gt;$.getJSON('http://www.baidu.com/json/?callback=?',function(response)&#123; ......处理数据&#125;);&lt;/script&gt; 这里我们不需要手动的插入script标签以及定义回调函数，jquery会自动生成一个全局函数来替换callback=?中的问号，之后获取到数据后又会自动销毁，实际上就是起一个临时代理函数的作用。$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法；跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。 缺点：1、从其他域加载代码执行，可能会夹带恶意代码导致不安全可靠。2、确定JSONP请求是否失败不容易。 修改document.domain方法跨子域我们前面说到同源策略，其限制之一就是第一种方法中我们说的不能通过ajax的方法去请求不同源中的文档。 它的第二个限制是浏览器中不同域的框架之间是不能进行js的交互操作的。一般来说，不同的框架之间（父子或同辈），是能够获取到彼此的window对象的，但却不能使用获取到的window对象的属性和方法。 举个例子：有一个页面，它的地址是http://www.example.com/a.html ， 在这个页面里面有一个iframe，它的src是http://example.com/b.html, 很显然，这个页面与它里面的iframe框架是不同域的，所以我们是无法通过在页面中书写js代码来获取iframe中的东西的。 那么在满足主域相同的前提下，我们通过修改这两个页面的document.domain，把它们设成相同的域名就可以实现跨域了。例如：在页面 http://www.example.com/a.html 中： 1234567&lt;iframe src="http://www.example.com/b.html" id="iframe" onload="tese()"&gt;&lt;/iframe&gt;&lt;script&gt;document.domain='example.com';//设置成主域function test()&#123; alert(document.getElementById("iframe").contentWindow);//这里就可以访问获得此属性了，而之前不行。&#125;&lt;/script&gt; 在页面 http://example.com/b.html 中：123&lt;script&gt;document.domain="example.com";&lt;/script&gt; 这里需要注意的几个问题： document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。 我们必须显示的设置document.domain的值，即使和原来的相同。如上面例子中的b页面。 修改document.domain的方法只适用于不同子域的框架间的交互，通过Ajax直接请求还是不行。 window.name方法window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面（甚至不同域名）都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置，并且可以支持非常长的 name 值（2MB）。 具体跨域过程：1、需要传递数据的页面里的代码很简单，就是给当前的window.name设置一个需要获取数据的页面想要得到的数据值。2、在需要获取数据的页面中使用一个隐藏的iframe来获取需要传递数据页面的window.name的数据，把这个iframe的src设为需要传递数据的页面url即可。3、需要获得数据的页面还必须把这个iframe的src设成跟自身页面同一个域才行，这样才能访问到iframe里的window.name属性的。 代码举例可参考：http://www.cnblogs.com/2050/p/3191744.html window.postMessage方法window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。 调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符 * 。 需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中。举个例子，假设通过a.com/index.html向 b.com/index.html中传递消息：a.com/index.html中的代码： 123456789&lt;iframe id="ifr" src="b.com/index.html"&gt;&lt;/iframe&gt;&lt;script type="text/javascript"&gt;window.onload = function() &#123; var ifr = document.getElementById('ifr'); var targetOrigin = 'http://b.com'; // 若写成'http://b.com/c/proxy.html'效果一样 // 若写成'http://c.com'就不会执行postMessage了 ifr.contentWindow.postMessage('I was there!', targetOrigin);&#125;;&lt;/script&gt; b.com/index.html中的代码： 12345678910&lt;script type="text/javascript"&gt; window.addEventListener('message', function(event)&#123; // 通过origin属性判断消息来源地址 if (event.origin == 'http://a.com') &#123; alert(event.data); // 弹出"I was there!" alert(event.source); // 对a.com、index.html中window对象的引用 // 但由于同源策略，这里event.source不可以访问window对象 &#125; &#125;, false);&lt;/script&gt; 使用postMessage来跨域传送数据比较直观和方便的，缺点是IE6、IE7不支持。 Web Sockets方法web sockets是一种新浏览器的API，它的目标是在一个单独的持久连接上提供全双工、双向通信，而且同源策略对web sockets不适用。 web sockets原理是在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 具体可以详见我的另一篇博文：HTML5新特性之SSE和WebSocket 但是最大的限制条件就是只有在支持web socket协议的服务器上才能正常工作。 其他方法还有一种跨域请求技术是图像ping方法，是利用&lt;img&gt;标签实现。它是与服务器进行简单、单向的跨域通信的一种方法。请求从设置src属性那一刻起，但是最主要的两个缺点是：1、只能发送get请求。2、无法访问服务器的响应文本。所以只能是浏览器到服务器的单向通信，最常用于跟踪用户点击页面或动态广告曝光次数等。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS函数节流]]></title>
      <url>%2F2017%2F03%2F06%2FJS%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
      <content type="text"><![CDATA[[TOC] 前言本博文主要针对javascript中的函数节流的性能优化技巧进行总结。 应用背景我们知道浏览器中的DOM操作非常地消耗内存和CPU时间，连续尝试进行过多的DOM相关操作可能会导致浏览器挂起甚至崩溃。但是在浏览器 DOM 事件里面，有一些事件会随着用户的操作不间断触发。比如：重新调整浏览器窗口大小（resize），浏览器页面滚动（scroll），鼠标移动（mousemove）等。也就是说用户在触发这些浏览器操作的时候，如果脚本里面绑定了对应的事件处理方法，这个方法就不停的触发。那其中一个解决办法就是采用函数节流。 函数节流原理函数节流，就是对会频繁触发的函数事件做一些限制，让这些函数可以在每隔一定的时间或者每次满足一定的条件下再触发。背后思想就是某些代码不可以在没有间断的情况下连续重复执行。我们可以在第一次调用函数的时候创建一个定时器，在指定的时间间隔后运行代码，而在后面每次调用的时候都会清除前面一个并设置另一个定时器，类似于刷新的感觉。最终目的是使得执行函数只有在最后的请求停止了相应设置的一段时间之后才真正地去执行。 具体实现方法123456function throttle(method, scope) &#123; clearTimeout(method.tId); method.tId= setTimeout(function()&#123; method.call(scope); &#125;, 100); &#125; 上面这个throttle()函数可以实现自动进行定时器的设置和清除过程。这个函数接受要执行的函数和执行的作用域两个参数。首先清除之前设置的定时器，然后创建新的定时器并把返回值赋给方法的自定义属性中，便于下一次如果短时间内重复调用的清除，call()方法的使用使执行函数可以在我们想要的作用域中执行。这个函数的最终结果就是使得最后一次调用这个函数延迟100ms才能执行。 以节流在resize事件中的使用来进行实际的举例说明： 12345678function resizeDiv()&#123; var div = document.getElementById("myDiv"); div.style.height = div.offsetWidth + "px"; &#125; window.onresize = function()&#123; throttle(resizeDiv); &#125;; 这个执行resize事件的函数无论是计算offsetWidth属性还是设置某个元素的高度过程可能都会比较复杂，并涉及很多计算，所以为了浏览器性能考虑，我们最好控制处理频率，确保浏览器不会在极短时间内进行过多的计算。这里我们将原来的事件处理函数内容传入到了throttle函数里面去执行，通过前面的分析，我们可以知道，只有在改变窗口大小之后100ms内没有再次触发resize函数时才会调用执行函数，这样用户不会感觉到明显变化，但是浏览器节省了大量的计算，提高了性能。 这里就是我们虽然不能控制请求的频率，但是我们可以通过函数节流的方法控制执行的频率，从而达到节约浏览器性能的目的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端模块化和CommonJS，AMD，CMD规范]]></title>
      <url>%2F2017%2F02%2F25%2F%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8CCommonJS%EF%BC%8CAMD%EF%BC%8CCMD%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[前言本博文主要总结了我对前端模块化和CommonJS，AMD，CMD规范的理解以及应用方法。 前端模块化简单来说，前端模块化就是把复杂的文件分成一个个独立的模块，比如js文件，分成独立的模块之后有利于代码的重用和维护，但是这样又会引来模块与模块之间的依赖问题，所以就有了CommonJS、AMD、CMD规范。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。而且模块开发需要遵循一定的规范，否则容易乱套。 我们知道，在java中，有一个package的重要概念，逻辑上相关的代码组织到同一个包内，包内是相对独立的，不用担心命名冲突等，那么外部使用方法是直接import对应的package即可，如： 1import java.util.ArrayList; 但是JavaScript在设计时定位原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。 目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD。 CommonJS规范 CommonJS是在浏览器环境之外构建JavaScript生态系统为目标产生的项目，比如服务器和桌面环境中。CommonJS规范是为了解JavaScript的作用域问题而定义的模块形式，可以使每个模块在它自身的命名空间中执行。 在网页端没有模块化编程只是页面JavaScript逻辑复杂，但也可以工作下去，在服务器端却一定要有模块，所以虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来。2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程，这标志”Javascript模块化编程”正式诞生。 主要内容由以下三个部分组成： 定义模块：根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 模块输出：模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。 加载模块：加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象。如下例子所示： 123456789101112131415//模块定义 myModel.jsvar name = 'Byron';function printName()&#123; console.log(name);&#125;function printFullName(firstName)&#123; console.log(firstName + name);&#125;module.exports = &#123; printName: printName, printFullName: printFullName&#125;//加载模块var nameModule = require('./myModel.js');nameModule.printName(); 浏览器环境问题由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。require是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。 举个例子，假定有一个数学模块math.js，就可以像下面这样加载和调用模板提供的方法： 12var math = require('math'); math.add(1, 2); math.add(2, 3)在require(‘math’)之后运行，因此必须等math.js加载完成。如果加载时间很长，整个应用就会停滞了。因此，浏览器端的模块，不能采用同步加载，只能采用异步加载。这就是AMD规范诞生的背景。 AMD规范AMD 即Asynchronous Module Definition，中文名是异步模块定义的意思，它是一个在浏览器端模块化开发的规范。由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数RequireJS，实际上AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 AMD 采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 requireJS主要解决两个问题： 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长 AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数： 1require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如： 123require(['math'], function (math) &#123; math.add(1,2); &#125;); 这是上面的例子，这样实现就会使math.add()与math模块加载不是同步的，而是通过回调函数异步调用。所以AMD解决了前面提到的问题。 下面来说说RequireJS的具体使用：下载好放入相应目录中，在html文件中引用，同时假定我们自己的代码文件是main.js： 1&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 假设主模块依赖于其他模块，则在main.js中： 1234 // main.js require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC)&#123; // some code here &#125;); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。如： 123require(['jquery', 'underscore', 'backbone'], function ($, _, Backbone)&#123; // some code here &#125;); 使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。如：require.config({ 123456 paths: &#123; "jquery": "lib/jquery.min", "underscore": "lib/underscore.min", "backbone": "lib/backbone.min" &#125; &#125;); 如果某个模块在另一台主机上，也可以直接指定它的网址，如： 12345require.config(&#123; paths: &#123; "jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min" &#125; &#125;); require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。具体来说，就是模块必须采用特定的define()函数来定义。如： 12345678910111213// math.js define(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;; &#125;); // main.js require(['math'], function (math)&#123; alert(math.add(1,1)); &#125;); 定义和调用如上所示。 如果被调用的这个模块本身还依赖其他模块，则这么写： 12345678 define(['myLib'], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;; &#125;); 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。 总结来说，函数 define，它是全局变量，用来定义模块：1define(id(可选), dependencies(可选), factory); 其中id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）；dependencies：是一个当前模块依赖的模块名称数组；factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值在页面上使用require函数加载模块。1require([dependencies], function()&#123;&#125;); require()函数接受两个参数，第一个参数是一个数组，表示所依赖的模块第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 AMD规范对于依赖的模块提前执行，依赖前置。优点：适合在浏览器环境异步加载；并行加载多个模块。缺点：提高开发成本，代码阅读和书写比较困难；不符合通用的模块思维方式，是一种妥协的实现。 CMD规范CMD 即Common Module Definition通用模块定义，CMD规范是国内发展出来的，就像AMD有个requireJS，CMD有个浏览器的实现SeaJS，SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。 CMD规范和AMD相似，尽量保持简单，并且与CommonJS和NodeJS的Modules规范保持了很大的兼容性。 CMD的特点： 推崇一个模块一个文件，经常就用文件名作为模块id。 推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写。 1define(id(可选), dependencies(可选), factory); 与上面类似，不过factory有三个参数： 1function(require, exports, module) require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口；exports 是一个对象，用来向外提供模块接口；module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 引用官网中的例子：两个模块 spinning.js 和 main.js，遵循统一的写法： 1234567891011121314// 所有模块都通过 define 来定义define(function(require, exports, module) &#123; // 通过 require 引入依赖 var $ = require('jquery'); var Spinning = require('./spinning'); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ...&#125;); 然后在html文件=页尾，通过 script 引入 sea.js 后，有一段配置代码： 12345678910// seajs 的简单配置seajs.config(&#123; base: "../sea-modules/", alias: &#123; "jquery": "jquery/jquery/1.10.1/jquery.js" &#125;&#125;)// 加载入口模块seajs.use("../static/hello/src/main") sea.js 在下载完成后，会自动加载入口模块。再如下面这个例子： 12345678910// 定义模块 myModule.jsdefine(function(require, exports, module) &#123; var $ = require('jquery.js') $('div').addClass('active');&#125;);// 加载模块seajs.use(['myModule.js'], function(my)&#123;&#125;); 总体来说 ，CMD规范优点是依赖就近，延迟执行，很容易在node中运行。缺点是依赖SPM打包，模块的加载逻辑偏重。 比较AMD与CMD他们最大的区别在于模块定义时对依赖的处理不同：AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块；CMD推崇就近依赖，只有在用到某个模块的时候再去require获得。但是requireJS和SeaJS都支持对方的写法。 AMD与CMD都是异步加载模块，AMD在加载模块完成后就会执行模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。而CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新特性之SSE和WebSocket]]></title>
      <url>%2F2017%2F02%2F13%2FHTML5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BSSE%E5%92%8CWebSocket%2F</url>
      <content type="text"><![CDATA[前言本博文主要记录了对HTML5的服务器发送事件(SSE)和WebSocket相关内容的理解与总结。 服务器发送事件(SSE)服务器发送事件，即Server-Sent Events，指的是网页自动获取来自服务器的更新，是一种单向的消息传递。而以前的做法是网页需要去主动询问是否有可用的更新，而通过服务器发送事件，更新能够自动到达。这里注意IE浏览器均不支持服务器发送事件。 SSE具体过程首先一样，需要检测浏览器对SSE的支持情况： 12345678if(typeof(EventSource)!=="undefined")&#123;......&#125;else&#123;......&#125; 然后需要建立对象，创建时间，接受服务器的发送事件通知等。 12345var source=new EventSource("demo_sse.php");source.onmessage=function(event)&#123; document.getElementById("result").innerHTML+=event.data + "&lt;br&gt;";&#125;; 这里用new创建一个新的 EventSource 对象，然后规定发送更新的页面的 URL（本例中是 “demo_sse.php”），之后设置onmessage事件，每接收到一次更新，就会触发，当 onmessage 事件发生时，把已接收的数据event.data进行处理即可。 这里附php文件： 12345678&lt;?php header('Content-Type: text/event-stream'); header('Cache-Control: no-cache'); $time = date('r'); echo "data: The server time is: &#123;$time&#125;\n\n"; flush(); ?&gt; 这里需要注意的是，把 “Content-Type” 报头设置为 “text/event-stream”才可以发送事件流。 EventSource 对象除了可以用onmessage 事件来获取消息，还可以onopen事件打开通往服务器的连接，当发生错误时，还可以触发onerror事件进行处理。 WebSocketWebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。 WebSocket的属性、事件和方法属性 readyState：只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。 bufferedAmount：只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。 事件 open：事件处理程序为.onopen，在连接建立时触发 message：事件处理程序为.onmessage，在客户端接收服务端数据时触发。 error：事件处理程序为.onerror，在通信发生错误时触发 close：事件处理程序为.onclose，在连接关闭时触发 方法 send()：使用连接发送数据。 close()：关闭连接。 WebSocket具体实现WebSocket 协议本质上是一个基于 TCP 的协议。为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。 123456789101112131415161718192021222324function WebSocketTest() &#123; if ("WebSocket" in window) &#123; var ws = new WebSocket("ws://localhost:9998/echo"); ws.onopen = function() &#123; ws.send("发送数据"); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; &#125;; ws.onclose = function() &#123; ...... &#125;; &#125; else &#123; // 浏览器不支持 WebSocket ...... &#125; &#125; 首先依然是检验浏览器是否支持，然后创建 WebSocket 对象： 1var Socket = new WebSocket(url, [protocol] ); 以上代码中的第一个参数 url, 指定连接的 URL。第二个参数 protocol 是可选的，指定了可接受的子协议。之后连接建立时发送数据，接收到服务器数据时处理数据，然后关闭连接等。 1&lt;a href="javascript:WebSocketTest()"&gt;运行 WebSocket&lt;/a&gt; 通过点击这个即可运行这个函数。这里需要注意的是，在执行以上程序前，我们需要创建一个支持 WebSocket 的服务，我们需要安装 pywebsocket并开启相应的服务才可以。 SSE和WebSocket的理解与比较SSE是一种允许服务器端向客户端推送新数据（简称数据推送）的HTML5技术。数据推送有两种替代方案：无更新方案和数据拉取方案。无更新方案：加载完毕HTML之后，得到一个HTML页面，之后浏览器会请求图片、CSS文件和JavaScript文件等，他们都是浏览器可以缓存的静态文件。如果页面使用后端语言，比如PHP、Ruby和Python等为用户动态生成HTML的语言。数据拉取方案：浏览器会基于一些用户行为，或在一定时间之后，或基于某种别的触发方案，向服务器端请求或全部更新数据，通过javascript或一个meta标签能够命令整个页面重新加载。我们所熟悉的Ajax技术只被用于请求最新数据，当收到数据时，javascript函数会利用它来局部更新DOM。数据拉取的要义：仅拉取新数据，并且只更新页面中受影响部分。 以上的都不是数据推送，数据推送不是静态文件，也不涉及浏览器为更新数据而发起请求，数据推送是由服务器选择客户端发送新数据。当数据源有新数据时，服务器端能立刻发送给一个或多个客户端，而不用等客户端来请求，这些新数据可能是突发新闻、最新股票、上线朋友的聊天信息、新的天气预报、策略游戏中的下一步等。 而websocket是浏览器向服务端发送一个请求，通过报文头部Upgrade来表明需要从HTTP切换至Websocket协议。 12345678GET ws://echo.websocket.org/?encoding=text HTTP/1.1Origin: http://websocket.orgCookie: __utma=99asConnection: UpgradeHost: echo.websocket.orgSec-WebSocket-Key: uRovscZjNol/umbTt5uKmw==Upgrade: websocketSec-WebSocket-Version: 13 如果服务端理解websocket协议，它也是通过报文Upgrade从HTTP转换为Websocket协议。 123456789HTTP/1.1 101 WebSocket Protocol HandshakeDate: Fri, 10 Feb 2012 17:38:18 GMTConnection: UpgradeServer: Kaazing GatewayUpgrade: WebSocketAccess-Control-Allow-Origin: http://websocket.orgAccess-Control-Allow-Credentials: trueSec-WebSocket-Accept: rLHCkw/SKsO9GAH/ZSFhBATDKrU=Access-Control-Allow-Headers: content-type 这个时候就建立起了websocket连接，基于TCP/IP。 除了websocket之外，浏览器进行即时通信的方式还有以下几种： 定期查询。每隔一个时间段就向服务器发送一个请求，请求服务器的最新数据再进行更新。但这样做的后果就是浪费大量流量，对服务端造成了巨大压力。 Comet基于http长连接的“服务器推”技术。客户端与服务器端保持一个长连接，只有客户端需要的数据更新时，服务器才主动将数据推送给客户端。有两种形式： 基于Ajax的长轮询（long-polling）方式浏览器发出XMLHttpRequest请求，服务器端接收到请求后，会阻塞请求直到有数据或者超时才返回，浏览器在处理请求返回信息（超时或有效数据）后再次发出请求，重新建立连接。在此期间服务器端可能已经有新的数据到达，服务器会选择把数据保存，直到重新建立连接，浏览器会把所有数据一次性取回。 基于Iframe及htmlfile的流（http streaming）方式通常的做法是在页面中嵌入一个隐藏的iframe,然后让这个iframe的src属性指向我们请求的一个服务端地址，并且为了数据更新，我们将页面上数据更新操作封装为一个js函数，将函数名当做参数传递到这个地址当中。服务端收到请求后解析地址取出参数（客户端js函数调用名），每当有数据更新的时候，返回对客户端函数的调用，并且将要跟新的数据以js函数的参数填入到返回内容当中，例如返回&lt;script type=&quot;text/javascript&quot;&gt;update(&quot;data&quot;)&lt;/script&gt;这样一个字符串，意味着以data为参数调用客户端update函数进行客户端view更新。流不同于上述两种轮询（短轮询和长轮询），因为它在页面的整个生命周期内只使用一个HTTP 连接。当应用程序有高吞吐量的需求，Comet的长轮询就不适合了。 SSE(服务端推送事件)是一种允许服务端向客户端推送新数据的HTML5技术。与websocket相比，WebSocket相较SSE最大的优势在于它是双向交流的，这意味向服务端发送数据就像从服务端接收数据一样简单。用SSE时，一般通过一个独立的Ajax请求从客户端向服务端传送数据。相对于WebSocket，这样使用Ajax会增加开销，但也就多一点点而已。 相比于间断的轮询或长轮询来模拟全双工连接的解决方式，Websocket极大的减少了不必要的网络流量和延迟。 SSE与WebSocket有相似功能，都是用来建立浏览器与服务器之间的通信渠道。两者的区别在于：WebSocket是全双工通道，可以双向通信，功能更强；SSE是单向通道，只能服务器向浏览器端发送。WebSocket是一个新的协议，需要服务器端支持；SSE则是部署在 HTTP协议之上的，现有的服务器软件都支持。SSE是一个轻量级协议，相对简单；WebSocket是一种较重的协议，相对复杂。SSE默认支持断线重连，WebSocket则需要额外部署。SSE不支持CORS ，参数url就是服务器网址，必须与当前网页的网址在同一个网域（domain），而且协议和端口都必须相同。而WebSocket支持。 总体来说，SSE适用于更新频繁、低延迟并且数据都是从服务端到客户端，不需要添加任何新组件，用任何习惯的后端语言和框架就能继续使用，不用为新建虚拟机弄一个新的IP或新的端口号而劳神，同时因为SSE能在现有的HTTP/HTTPS协议上运作，所以它能够直接运行于现有的代理服务器和认证技术。而WebSocket相较SSE最大的优势在于它是双向交流的，这意味着服务器发送数据就像从服务器接受数据一样简单，而SSE一般通过一个独立的Ajax请求从客户端向服务端传送数据，因此相对于WebSocket使用Ajax会增加开销。因此，如果需要以每秒一次或者更快的频率向服务端传输数据，就应该用WebSocket。 这部分详细内容请参考： websocket资料总结 【HTML5】WebSocket和SSE HTML5数据推送SSE原理及应用开发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新特性之Web Workers]]></title>
      <url>%2F2017%2F02%2F11%2FHTML5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BWeb%20Workers%2F</url>
      <content type="text"><![CDATA[前言本博文主要记录了对HTML5的新特性Web Workers相关内容的理解与总结。 Web Worker介绍web worker 是运行在后台的 JavaScript，不会影响页面的性能。我们知道，一般情况下，当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。但是现在有了Web Worker之后，它独立于其他脚本，不会影响页面的性能，而我们可以继续做点击、选取内容等其他事情，而此时 web worker 在后台运行。 具体实现过程这里我们用一个例子来进行说明： 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Web Workers实例&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;p&gt;计数： &lt;output id="result"&gt;&lt;/output&gt;&lt;/p&gt;&lt;button onclick="startWorker()"&gt;开始工作&lt;/button&gt; &lt;button onclick="stopWorker()"&gt;停止工作&lt;/button&gt;&lt;script&gt;var w;function startWorker() &#123; if(typeof(Worker) !== "undefined") &#123; if(typeof(w) == "undefined") &#123; w = new Worker("demo_workers.js"); &#125; w.onmessage = function(event) &#123; document.getElementById("result").innerHTML = event.data; &#125;; &#125; else &#123; document.getElementById("result").innerHTML = "浏览器不支持 Web Workers"; &#125;&#125;function stopWorker() &#123; w.terminate(); w = undefined;&#125;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 首先我们需要检测浏览器是否支持Web Worker： 1if(typeof(Worker) !== "undefined") 然后我们需要在外部JavaScript 中创建我们的 web worker脚本，这里我们写一个计数脚本，并命名为demo_workers.js： 12345678var i=0;function timedCount()&#123; i=i+1; postMessage(i); setTimeout("timedCount()",500);&#125;timedCount(); 其中postMessage() 方法是用于向 HTML 页面传回一段消息。 之后我们在html页面中通过new语句创建web worker 对象： 123if(typeof(w) == "undefined") &#123; w = new Worker("demo_workers.js"); &#125; 并向web worker对象实例中添加一个 “onmessage” 事件监听器，其中event.data就是前面postMessage() 方法传回来的消息数据。 创建 web worker 对象后，它会继续监听消息（即使在外部脚本完成之后）直到其被终止为止。最后终止Web Worker并释放浏览器/计算机资源，使用 terminate() 方法即可，并把实例对象置为”undefined”。 这里需要注意的是，由于 web worker 位于外部文件中，它们无法访问window 对象、document 对象和parent 对象等JavaScript 对象。 总结与理解Web Workers 是 HTML5 提供的一个javascript多线程解决方案，我们可以将一些大计算量的代码交由web Worker运行而不冻结用户界面。基本原理就是在当前javascript的主线程中，使用Worker类加载一个javascript文件来开辟一个新的线程，起到互不阻塞执行的效果， 当一个Worker实例被创建的时候，它会在一个全新的JavaScript运行环境中，完全和创建worker的脚本分离开，即使我们传递的消息是引用类型它们也是复制传递的，修改worker中的参数不影响创建脚本中的参数。 worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。 优势：1.可以加载一个JS进行大量的复杂计算而不挂起主进程，并通过postMessage，onmessage进行通信。2.可以在worker中通过importScripts(url)加载另外的脚本文件。。3.可以使用 setTimeout(), setInterval()及其清除方法。4.可以使用XMLHttpRequest来发送请求。5.可以访问navigator的部分属性。6.可以使用JavaScript的全局对象：JSON、Date()、Array。7.可以进行self自身引用。8.可以只读location对象。9.可以使用addEventListener()、removeEventListener()等方法。 局限：1.不能跨域加载JS。2.worker内代码不能访问DOM。3.各个浏览器对Worker的实现不大一致，例如FF里允许worker中创建新的worker,而Chrome中就不行。4.不是每个浏览器都支持这个新特性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新特性之应用程序缓存]]></title>
      <url>%2F2017%2F02%2F10%2FHTML5%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[前言本博文主要记录了对HTML5的新特性应用程序缓存相关内容的理解与总结。 应用程序缓存介绍HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。而使用 HTML5，通过创建 cache manifest 文件，可以轻松地创建 web 应用的离线版本。举个例子： 12345678&lt;!DOCTYPE HTML&gt;&lt;html manifest="demo.appcache"&gt;&lt;body&gt;文档内容......&lt;/body&gt;&lt;/html&gt; 这是带有 cache manifest 的HTML文档，在文档的html标签中包含 manifest 属性，可以实现这个html页面的离线浏览。 Manifest在文档的html标签中包含 manifest 属性即可启用应用程序缓存，每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存，当然有一种情况例外，就是在 manifest 文件中直接指定了该页面。manifest 文件的建议的文件扩展名是：”.appcache”。 这里需要注意的是，manifest 文件需要配置正确的 MIME-type，即 “text/cache-manifest”，而且必须在 web 服务器上进行配置。 manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存 NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存 FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 举个例子： 1234567891011CACHE MANIFEST# 注释内容/theme.css/logo.gif/main.jsNETWORK:login.phpFALLBACK:/html/ /offline.html 以 “#” 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。 第一行的CACHE MANIFEST是必需的，这里列出了三个资源：一个 CSS 文件，一个 GIF 图像，以及一个 JavaScript 文件。当 manifest 文件加载后，浏览器会从网站的根目录下载这三个文件。然后，无论用户何时与因特网断开连接，这些资源依然是可用的。 NETWORK 小节规定文件 “login.php” 永远不会被缓存，且离线时是不可用的，可以使用星号来指示所有其他其他资源/文件都需要因特网连接： 12NETWORK:* 最后 FALLBACK 小节规定如果无法建立因特网连接，则用 “offline.html” 替代 /html/ 目录中的所有文件，这里的第一个 URI 是资源，第二个是替补。 更新缓存方法一旦应用被缓存，它就会保持缓存直到发生下列情况： 用户清空浏览器缓存 manifest 文件被修改(如前面提到的更新注释里的内容) 由程序来更新应用缓存这里需要注意的是，一旦文件被缓存，则浏览器会继续展示已缓存的版本，即使您修改了服务器上的文件。 应用程序缓存的优势 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 注意的问题 Application Cache的尺寸限制统一在5M，当 文件超过尺寸限制时，会导致另一些文件缓存失效，所以建议Application Cache存储公共资源，不要存储业务资源。 由更新机制来说，首次更新manifest时，因为页面加载已经开始甚至已经完成，缓存更新尚未完成，浏览器仍然会使用过期的资源；浏览器是当Application Cache有更新时，该次不会使用新资源，第二次才会使用。 各个页面统一管理自己的manifest清单，意思是a页面配置了common.js，b页面也配置了common.js，如果a页面更新后，b页面的manifest不更改的话，b页面依旧读取的是老版本的文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5新特性之web存储]]></title>
      <url>%2F2017%2F02%2F09%2FHTML5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bweb%E5%AD%98%E5%82%A8%2F</url>
      <content type="text"><![CDATA[前言本博文主要记录了对HTML5的新特性web存储相关内容的理解与总结。 web存储介绍在html5出现之前，本地存储主要使用的是 cookie。cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。而现在，可以使用HTML5在本地存储用户的浏览数据。数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。 对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。当然，存储和访问数据是利用javascript来实现的。 HTML5 web 存储,一个比cookie更好的本地存储方式。 HTML5 提供了两种在客户端存储数据的新方法：localStorage ： 这是没有时间限制的数据存储方法sessionStorage ：这是针对一个 session 的数据存储方法 在使用 web 存储前,应检查浏览器是否支持 localStorage 和sessionStorage: 1234567if(typeof(Storage)!=="undefined")&#123;......&#125; else &#123;......&#125; localStoragelocalStorage 存储的数据没有时间限制。看个例子： 123456789if (localStorage.clickcount)&#123; localStorage.clickcount=Number(localStorage.clickcount)+1;&#125;else&#123; localStorage.clickcount=1;&#125;document.getElementById("result").innerHTML=" 你已经点击了按钮 " + localStorage.clickcount + " 次 "; clickcount和后面的点击次数的数值创建了一个 localStorage键值对，这样当我们点击按钮时触发事件可以把点击次数保存下来。而这时无论是我们刷新页面或者关闭浏览器窗口，这个存储下来的点击次数值都不会丢失或重置。 sessionStoragesessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。看一个和上面类似的例子： 123456789if (sessionStorage.clickcount)&#123; sessionStorage.clickcount=Number(sessionStorage.clickcount)+1;&#125;else&#123; sessionStorage.clickcount=1;&#125;document.getElementById("result").innerHTML="在这个会话中你已经点击了该按钮 " + sessionStorage.clickcount + " 次 "; 这里换成sessionStorage方法来存储点击的次数了，这时当我们刷新页面的时候，点击次数值可以保存下来，但是当我们关闭浏览器窗口的时候再打开的时候，这个值已经被重置了。 常用API不管是 localStorage，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）： 保存数据：localStorage.setItem(key,value); 读取数据：localStorage.getItem(key); 删除单个数据：localStorage.removeItem(key); 删除所有数据：localStorage.clear(); 得到某个索引的key：localStorage.key(index); 注意： 键/值对通常以字符串存储，你可以按自己的需要转换该格式。 cookies，sessionStorage 和 localStorage 的区别 cookie: cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage 不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 作用域不同: sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面； localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。 Web Storage 的 api 接口使用更方便。 Web Storage的优势使用 local storage和session storage主要通过在js中操作这两个对象来实现，分别为window.localStorage和window.sessionStorage。这两个对象均是Storage类的两个实例，自然也具有Storage类的属性和方法。 减少网络流量：一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。 快速显示数据：性能好，从本地读数据比通过网络从服务器获得数据快得多，本地数据可以即时获得。再加上网页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示。 临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于AngularJS的抽奖系统练习总结]]></title>
      <url>%2F2017%2F01%2F23%2F%E5%9F%BA%E4%BA%8EAngularJS%E7%9A%84%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作基于AngularJS的抽奖系统demo过程中的一些心得和技巧。抽奖系统应用很广泛，基于AngularJS的抽奖系统具有代码清晰简洁，较高的执行效率和较强的扩展性等优势。这个抽奖系统主要包括以下一些效果及功能： 可以点击开始按钮进行抽奖 抽奖过程具有闪烁效果，在所有奖品上循环一定次数之后自动随机选择出中奖奖品，并显示在页面上。 结束抽奖之后，可以选择重新开始抽奖，还可以选择对奖品进行修改，包括对已有商品的删除和增加奖品等。 心得与技巧整体设计思路基于AngularJS框架，只需一个单页即可完成所需功能与要求。主要分为四个页面元素： 抽奖开始的初始化页面元素 抽奖过程中闪烁选择的页面元素 抽中奖品时显示奖品的页面元素 增加或删除奖品的页面元素 而这四个页面元素的切换可以通过放在不同的div容器中，然后通过控制容器的隐藏和显示来切换相应的页面元素。在这四个页面元素中，再分别初始化控制器数据，定义抽奖、中奖和修改奖品的方法等。值得一提的是，抽奖时奖品元素动态闪烁可以利用$timeout对象的注入来实现，而奖品信息也可以通过JSON格式来进行储存。 视图层的实现分析首先，在html标签上通过ng-app属性绑定页面模板名称，用于告诉 AngularJS 应用当前这个元素是根元素： 1&lt;html ng-app="lottery"&gt; 然后要记得用script标签引入angularjs的js文件： 1&lt;script src="lib/angular.min.js"&gt;&lt;/script&gt; 在body元素里，需要通过ng-controller属性定义控制器的作用域： 123&lt;div id="lottery" ng-controller="ctrl_lottery"&gt;......&lt;/div&gt; 这里我们将整个div中都定义为这个控制器的作用域，在这个作用域中，我们可以定义需要用到的元素变量，绑定数据和方法等。 之后主要分为四个大的div元素，和前面分析的一样，代表四种页面效果。这里设置每个div的名称时有个小技巧，即设置为”step1”、”step2”、”step3”、”step4”，这样后面在控制页面元素的时候，获取id的字符串，进行切换等操作都会相对比较方便。 第一个页面元素中主要是一个开始按钮，并用ng-click方式绑定了对应的方法： 1&lt;button ng-click="start()"&gt;开始&lt;/button&gt; 第二个页面元素主要是调用ng-repeat指令，这个指令可以用来遍历数组。同时用双大括号绑定了奖品的名称。这里最重要的是闪烁样式的确定，利用ng-class指令可以进行动态控制： 12345&lt;div ng-repeat="item in items" id="&#123;&#123;item.id&#125;&#125;" class="item" ng-class="&#123;'active':item.status&#125;"&gt; &#123;&#123;item.name&#125;&#125;&lt;/div&gt; 这里添加元素样式的方法是采用定义key/value的方式，即当“item.status”的值为true的时候，将”active”样式添加上去，反之则不添加，这样就可以实现闪烁样式的添加与删除了。 第三个页面元素主要是“重新开始”和“修改奖品”两个选择a元素的添加，同时用ng-click绑定对应的方法即可： 123456&lt;a href="javascript:void(0);" ng-click="reset()" class="reset"&gt; &lt;img src="images/reset.png"&gt;重新开始&lt;/a&gt;...... 这里值得注意的是，href=&quot;javascript:void(0);&quot;代表当触发a元素的时候，去执行相应绑定的js函数而不是去跳转地址。 第四个元素页面，主要是关于奖品的修改，除了和前面类似的一个返回按钮的设置之外，主要是增加和删除奖品两个部分的实现。 1234&lt;form ng-submit="add()"&gt; &lt;input type="text" class="add" ng-model="name" required placeholder="名称"&gt; &lt;input type="submit" class="btn" value="添加"&gt;&lt;/form&gt; 用ng-submit指令绑定对应方法，当type属性为submit的按钮被点击时，就会触发这个方法。ng-model指令将输入框中的输入值和name变量进行了双向绑定。 1234567&lt;ul&gt; &lt;li ng-repeat="item in items"&gt; &lt;span&gt;&#123;&#123;item.id&#125;&#125;&lt;/span&gt; &lt;span class="span"&gt;&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &lt;a href="javascript:void(0);" ng-click="del(item.id)"&gt;删除&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 而关于删除奖品这部分，先用ng-repeat指令循环遍历把奖品的信息和删除键都陈列出来，然后在删除键那里用ng-click绑定控制器中删除的方法即可。 js控制代码分析首先还是angularjs控制器的正常代码定义格式： 1234angular.module("lottery", []) .controller('ctrl_lottery', ['$scope', '$timeout', function($scope, $timeout) &#123; ...... &#125; 其中angular.module定义了 angular模块，是angularjs的代码入口，其中的名称就是前面页面中用ng-app绑定的名称。然后定义了控制器，控制器名称也与前面页面代码中绑定的名称一致，并注入需要用到的$scope和$timeout对象。 初始化方法用items来保存包含所有奖品的对象数组，然后定义两个通用的方法： 123456789$scope.$$ = function(id) &#123; return document.getElementById(id); &#125;;$scope.showhide = function(pre, nex) &#123; pre = "step" + pre; nex = "step" + nex; $scope.$$(pre).style.display = "none"; $scope.$$(nex).style.display = "block"; &#125;; 第一个方法根据元素id号来返回元素对象，第二个方法是切换页面元素的方法，只需传入对应的数字，即可完成页面切换，通过让前面一个页面隐藏和后面一个页面显示来达到效果，从这里也可以看出前面设置id的小技巧的用处了。 抽奖方法首先调用showhide()方法切换页面，然后定义循环圈数，其中最后选定第几号产品将随机产生： 1var selkey = Math.floor(Math.random() * $scope.items.length); 方法Math.random()随机产生一个大于等于0小于1的数字，然后乘以总个数之后再利用Math.floor方法进行向下取整，可以得到对应奖品的随机数字。 定义next()方法实现选中下一个进行闪烁，去掉上一个闪烁样式的效果： 12345678var next = function(key) &#123; $scope.items[key].status = true; if((key - 1) &gt;= 0) &#123; $scope.items[key -1].status = false; &#125; if(key == 0) &#123; $scope.items[$scope.items.length - 1].status = false; &#125; 具体通过对status标志的布尔值改变来实现。这里注意一旦超过一圈需要利用总个数处理判断。 $timeout方法是这个实现效果中的核心方法，实现思路是先判断跳动中当前的数字和总个数的关系，如果已完成一圈需要将代表圈数的变量减一，否则继续递归调用next()方法，直到circle圈数达到规定圈数，同时选中的奖品的所属次序也等于随机取的值为止： 123456789101112131415var timer = $timeout(function() &#123; if(circle &lt;= 0 &amp;&amp; selkey == key) &#123; $scope.showhide(2, 3); $scope.result = $scope.items[key].name; return; &#125; if($scope.items.length == key + 1) &#123; circle--; &#125; if($scope.items[key + 1]) &#123; next(key + 1); &#125; else &#123; next(0); &#125; &#125;, 100); 奖品显示页面方法这是第三个页面，除了显示奖品之外，只有重新开始抽奖和进入修改奖品页面这两个键，只需直接调用前面定义好的通用切换页面的方法即可： 123456$scope.reset = function() &#123; $scope.showhide(3, 1); &#125;; $scope.edit = function() &#123; $scope.showhide(3, 4); &#125;; 增删奖品的页面方法其实本质上就是对数组元素的增加或是删除，首先是增加奖品的方法： 1234$scope.add = function() &#123; var last_id = lastid(); $scope.items.push(&#123;id: last_id, name: $scope.name, status: 0&#125;); &#125;; 这里面用到了一个获取最后一个元素id号的方法，这个方法主要通过angular.foreach()遍历数组，从而在遍历结束时获取得到最后一个id号。获取了之后再加一，并采用数组的push()方法将增加的对象导入对象数组的最后一位即可。 下面是删除奖品的方法： 1234567$scope.del = function(id) &#123; angular.forEach($scope.items, function(value, key) &#123; if(id == value.id) &#123; $scope.items.splice(key, 1); &#125; &#125;) &#125;; 同样采用angular.foreach()遍历数组，这里需要注意的是，在这第二个参数即调用函数里面的参数，第一个代表的是数组元素值，第二个代表索引值。然后删除的方法是采用splice()方法，这个方法第一个参数代表删除的初始位置，第二个参数代表删除的个数。 总结在练习制作基于AngularJS的抽奖系统demo之后，加深了自己对于AngularJS制作单页应用开发的理解，也为自己后面的继续学习打下基础。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript关于DOM编程的最佳实践]]></title>
      <url>%2F2017%2F01%2F16%2FJavaScript%E5%85%B3%E4%BA%8EDOM%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[前言本博客记录总结了JavaScript关于DOM编程的一些最佳实践。 最佳实践web性能优化 尽量减少访问DOM只要是查询DOM中的某些元素，浏览器都会搜索整个DOM树，从中查找可能匹配的元素。1234567if(document.getElementsByTagName("a").length &gt; 0)&#123; var links = document.getElementsByTagName("a"); for(var i=0;i&lt;links.length;i++)&#123; //do something &#125;&#125; 上述代码中，执行document.getElementsByTagName(&quot;a&quot;).length时，会搜索整个DOM树；执行document.getElementsByTagName(&quot;a&quot;);时，会再次搜索整个DOM树。当DOM元素较多时，搜索整个DOM树是一个很耗时的操作。针对上述代码，作出如下优化：将第一次DOM树搜索的结果保存至一个变量中，将搜索次数减少1次。1234567var links = document.getElementsByTagName("a");if(links.length &gt; 0)&#123; for(var i=0;i&lt;links.length;i++)&#123; //do something &#125;&#125; 尽量减少文档中的标记数量。过多不必要的元素只会增加DOM树的规模，进而增加遍历DOM树以查找特定元素的时间。 将多个js文件合并并放置在合适的位置将多个js文件合并，可以减少HTTP请求次数。 根据HTTP规范，浏览器每次从同一个域名中最多只能同时下载2个文件。 将引入的外部js文件的&lt;script&gt;标签放置到文档的末尾（&lt;/body&gt;标签之前），可以使页面更快的加载。若将&lt;script&gt;标签放置于&lt;head&gt;中，则执行到&lt;script&gt;标签时，浏览器会先加载js文件，加载完成后才会执行&lt;body&gt;标签中的内容，才会创建DOM树，这样会影响页面加载速度。 压缩脚本脚本文件编写完成后，进行脚本压缩，可以减少文件体积，减轻服务器压力。在实际的工程中，可以保存2个版本的脚本：一个工作副本，用于修改，调试和注释；一个精简副本，压缩之后上传到服务器。精简副本（压缩后的脚本）一般在文件名中后缀上min进行标识。 常用的脚本压缩工具如下所示。[1] Douglas Crockford的JSMin[2] Yahoo的YUI Compressor[3] Google的Closure Compiler[4] Javascript压缩混淆工具比较分析 平稳退化如果正确地使用了js脚本，就可以让访问者在他们的浏览器不支持js或者禁用js的情况下，仍然能够顺利地访问你的网站，最基本的操作仍然能顺利实现（虽然有可能部分功能无法使用），这就是平稳退化。（Graceful Degradation，也叫做优雅降级） 此处以Google网站为例，说明平稳退化。访问Google网站，若此时浏览器支持js，点击右上角的Google应用图标，则会弹出一个下拉框，下拉框中显示了各种Google应用；若浏览器禁用了js或者不支持js，点击右上角的Google应用图标，则会跳转至Google Product网页。 上述功能，可以用下述代码实现。1&lt;a href="https://www.google.com/intl/zh-CN/about/products" onclick="myFunctionName(); return false"&gt;Baidu&lt;/a&gt; 当浏览器支持js时，点击&lt;a&gt;标签，执行myFunctionName()函数（实现对应的效果，比如显示一个下拉框）；此时，由于return false的存在，会阻止&lt;a&gt;标签的默认行为，禁止跳转至新的界面。若浏览器不支持js，则点击 &lt;a&gt;标签，会执行&lt;a&gt;标签的默认行为，跳转至href指定的网址中。 本章节参考资料：[1] JavaScrtip之平稳退化[2] 渐进增强与平稳退化[3] javascript平稳退化 渐进增强 所谓的”渐进增强”就是使用一些额外的信息层去包裹原始数据。按照”渐进增强”原则创建出的网站几乎（如果不是“全部”的话）都会支持”平稳退化”。 渐进增强原则基于这样一种思想：你应该总是从最核心的部分，也就是从内容开始。应该根据内容使用标记良好的结构；然后再逐步加强这些内容。这些增强工作可以是通过CSS改进呈现效果，也可以是通过DOM添加各种行为。如果你使用DOM添加内容核心，那么你添加的未免太迟了，内容应该在刚开始编写文档时就成为文档的组成部分。 例如，1&lt;p&gt; Welcome,Shanghai! &lt;/p&gt; 上述代码中的&lt;p&gt;元素时页面中最核心的内容。下面考虑渐进增强，若页面支持CSS3，可以对其样式修饰。即使页面不支持CSS3，页面仍然能正常显示，符合“平稳退化”。在判断文档中是否支持CSS或者js或者DOM行为等时，可以采用对象检测(Object Detection)（参见5.4 向后兼容 章节）。 本章节参考资料：[1] 什么是“平稳退化”和“渐进增强”理念？ 向后兼容1234if(method)&#123; statements;&#125;//else&#123; &#125; 对象检测(Object Detection)的使用方式如上述代码所示。将某一个方法method打包在if语句中，若支持该方法，则执行相应的操作。 这样编写代码，可以保证向后兼容。即若浏览器对js或DOM支持程度较高，支持某些的方法，则调用该方法。对于比较古老的浏览器，若不支持该方法，则执行else语句中的内容。从而保证了对新浏览器或新语法的支持，这就是向后兼容。 向后兼容的实例如下所示。123if(document.getElementsByClassName)&#123; var content = document.getElementsByClassName("content");&#125; 工程中更常用的做法为若不支持该方法，则返回false。使用或符号，可以同时检测多个方法。12if(!method1 || !method2 || !method3) return false;//do something with these methods 或者123var support = method1 &amp;&amp; method2 &amp;&amp; method2if(!support) return false;//do something with these methods]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基于Bootstrap的前端框架介绍网页练习总结]]></title>
      <url>%2F2017%2F01%2F09%2F%E5%9F%BA%E4%BA%8EBootstrap%E7%9A%84%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D%E7%BD%91%E9%A1%B5%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了自己在练习制作基于Bootstrap的前端框架介绍网页时的心得和技巧。 心得与技巧bootstrap格式问题的说明1&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 其中X-UA-Compatible代表着文件兼容性，即定义让浏览器如何编译网页，这里指定为IE=edge，代表指示IE以目前可用的最高模式显示内容。 1&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 其中name=&quot;viewport&quot;代表可视区域，content中width=device-width代表显示窗口的宽度和设备屏幕的宽度一致， initial-scale=1表示初始缩放比例为1。这是为了符合移动端等的响应式布局。 1234&lt;!--[if lt IE 9]&gt; &lt;script src="js/html5shiv.js"&gt;&lt;/script&gt; &lt;script src="js/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; 其中html5shiv.js文件是解决IE6、7、8版本（IE9以下版本）浏览器兼容html5新增的标签的问题，而respond.min.js是解决IE6、7、8版本浏览器兼容css3样式的问题。 1&lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; 这是引入bootstrap的css样式。 12&lt;script src="js/jquery-1.11.1.min.js"&gt;&lt;/script&gt;&lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt; 这里引用jQuery文件和bootstrap的js文件，这里需要注意的是由于bootstrap中的js插件是依赖于jQuery的，所以jQuery文件需要在bootstrap的js文件之前引用。 这里附上bootstrap的通用html格式的模板： 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Bootstrap的HTML标准模板&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!--你自己的样式文件 --&gt; &lt;link href="css/your-style.css" rel="stylesheet"&gt; &lt;!-- 以下两个插件用于在IE8以及以下版本浏览器支持HTML5元素和媒体查询，如果不需要用可以移除 --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;!-- 如果要使用Bootstrap的js插件，必须先调入jQuery --&gt; &lt;script src="http://libs.baidu.com/jquery/1.9.0/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 包括所有bootstrap的js插件或者可以根据需要使用的js插件调用 --&gt; &lt;script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 导航条这个前端框架介绍网页的一开始就会用到导航条，导航条是网站中的基础组件，它在移动设备上可以折叠。一个导航条的基本结构如下所示： 1234567891011121314151617181920&lt;div class="navbar navbar-inverse navbar-fixed-top" role="navigation" id="menu-nav"&gt; &lt;div class="container"&gt; &lt;div class="navbar-header"&gt; &lt;button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse"&gt; &lt;span class="sr-only"&gt;切换导航&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;span class="icon-bar"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class="navbar-brand" href="#"&gt;多种前端框架介绍&lt;/a&gt; &lt;/div&gt; &lt;div class="navbar-collapse collapse"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;li class="active"&gt;&lt;a href="#ad-carousel"&gt;综述&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#summary-container"&gt;简述&lt;/a&gt;&lt;/li&gt; ...... &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 其中button标签那段代码可以达到一种当屏幕宽度小于某个值的时候可以折叠起来显示的效果。Data-toggle是说明使用哪个组件，这里使用的是Collapse组件。data-target是指使用的目标元素。sr-only指除了屏幕阅读器之外，其他的都隐藏这个元素，不予显示。 这个navbar-fixed-top类的添加可以让导航条固定在顶部。包含一个container或者container-fluid的容器，可以让导航条居中或者自适应显示。添加navbar-inverse类可以改变导航条的外观，变成黑底显示。 前面我们说了这个navbar-fixed-top类的添加可以让导航条固定在顶部，但是这里需要说明的是固定的导航条会遮住页面上的其他内容，除非给body元素设置padding值，导航条的默认高度是50px，我们可以给之设置上内边距为70px左右。 下拉菜单12345678910&lt;li class="dropdown"&gt; &lt;a href="#" class="dropdown-toggle" data-toggle="dropdown"&gt;特点 &lt;span class="caret"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class="dropdown-menu" role="menu"&gt; &lt;li&gt;&lt;a href="#feature-tab" data-tab="tab-jquery"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#feature-tab" data-tab="tab-bootstrap"&gt;Bootstrap&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#feature-tab" data-tab="tab-angularjs"&gt;AngularJS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#feature-tab" data-tab="tab-reactjs"&gt;ReactJS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#feature-tab" data-tab="tab-vuejs"&gt;VueJS&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; 这是下拉菜单应用的结构，这里需要注意的是，这里可以仅仅通过data属性API就能使用所有的Bootstrap插件，而不需要用到js去写代码，可以称为是bootstrap中的一等API，是首选方式。 滚动广告在网页的上部分有个很大的滚动广告区域，这里我们使用的是一个组件Carousel，这是一个用于轮播内容的组件，也就是我们经常用到的滚动广告或是滚动图片。主要结构如下所示： 123456789101112131415161718192021222324252627282930&lt;div id="ad-carousel" class="carousel slide" data-ride="carousel"&gt; &lt;ol class="carousel-indicators"&gt; &lt;li data-target="#ad-carousel" data-slide-to="0" class="active"&gt;&lt;/li&gt; &lt;li data-target="#ad-carousel" data-slide-to="1"&gt;&lt;/li&gt; &lt;li data-target="#ad-carousel" data-slide-to="2"&gt;&lt;/li&gt; &lt;li data-target="#ad-carousel" data-slide-to="3"&gt;&lt;/li&gt; &lt;li data-target="#ad-carousel" data-slide-to="4"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;div class="carousel-inner"&gt; &lt;div class="item active"&gt; &lt;img src="images/jquery-big.jpg" alt="1 slide"&gt; &lt;div class="container"&gt; &lt;div class="carousel-caption"&gt; &lt;h1&gt;jQuery&lt;/h1&gt; &lt;p&gt;&lt;a class="btn btn-lg btn-primary" href="http://jquery.com/" role="button" target="_blank"&gt;点我下载&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="item"&gt; &lt;img src="images/bootstrap-big.jpg" alt="2 slide"&gt; ...... &lt;a class="left carousel-control" href="#ad-carousel" data-slide="prev"&gt;&lt;span class="glyphicon glyphicon-chevron-left"&gt;&lt;/span&gt;&lt;/a&gt; &lt;a class="right carousel-control" href="#ad-carousel" data-slide="next"&gt;&lt;span class="glyphicon glyphicon-chevron-right"&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt; data-ride=&quot;carousel&quot; 属性用于标记轮播在页面加载时就开始动画播放，无需使用初始化的js函数。使用 data 属性可以很容易控制轮播（Carousel）的位置。属性 data-slide 接受关键字 prev 或 next，用来改变幻灯片相对于当前位置的位置。使用 data-slide-to 来向轮播床底一个原始滑动索引， 将把滑块移动到一个特定的索引，索引从 0 开始计数。当然除了应用bootstrap自带的样式之外，还可以自己设置css样式进行必要的微调。 栅格系统布局这广告区域下方的简述部分内容采用了栅格系统布局：1234567891011&lt;div class="row" id="summary-container"&gt; &lt;div class="col-md-4"&gt; ...... &lt;/div&gt; &lt;div class="col-md-4"&gt; ...... &lt;/div&gt; &lt;div class="col-md-4"&gt; ...... &lt;/div&gt; &lt;/div&gt; 这是典型的栅格系统布局，其中行(row)必须包含在.container(固定宽度)或.container-fluid(100%宽度)中。而这里使用col-md-栅格类，可以创建一个基本的栅格系统，在手机和平板上一开始是堆叠在一起的，在桌面(&gt;970px)屏幕设备上变为水平排列。这也是响应式布局的一个经典实现。 标签页在前端框架特点的详细叙述那里采用了标签页，标签页是一个经常使用的组件，可以放置较多的内容的同时，还可以节省较大的页面空间。如下是实现标签页的结构： 1234567891011121314151617181920212223&lt;ul class="nav nav-tabs" role="tablist" id="feature-tab"&gt; &lt;li class="active"&gt;&lt;a href="#tab-jquery" role="tab" data-toggle="tab"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#tab-bootstrap" role="tab" data-toggle="tab"&gt;Bootstrap&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#tab-angularjs" role="tab" data-toggle="tab"&gt;AngularJS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#tab-reactjs" role="tab" data-toggle="tab"&gt;ReactJS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#tab-vuejs" role="tab" data-toggle="tab"&gt;VueJS&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="tab-content"&gt; &lt;div class="tab-pane active" id="tab-jquery"&gt; &lt;div class="row feature"&gt; &lt;div class="col-md-7"&gt; &lt;h2 class="feature-heading"&gt;jQuery &lt;span class="text-muted"&gt;write Less，Do More&lt;/span&gt;&lt;/h2&gt; &lt;p class="lead"&gt;倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。&lt;/p&gt; &lt;/div&gt; &lt;div class="col-md-5"&gt; &lt;img class="feature-image img-responsive" src="images/jquery-logo.jpg" alt="jquery"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 同样无需写任何javascript代码，只需简单地为页面元素指定data-toggle=&quot;tab&quot;，为ul添加nav和nav-tabs的class即可。 弹出框(模态框)在网页上面关于那一栏点击就会有弹出框的效果，弹出框也是一个经常使用的组件，一般用于弹出提示信息，确认信息和表单等内容。 123456789101112131415161718&lt;div class="modal fade" id="about-modal" tabindex="-1" role="dialog" aria-labelledby="modal-label" aria-hidden="true"&gt; &lt;div class="modal-dialog"&gt; &lt;div class="modal-content"&gt; &lt;div class="modal-header"&gt; &lt;button type="button" class="close" data-dismiss="modal"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;span class="sr-only"&gt;关闭&lt;/span&gt;&lt;/button&gt; &lt;h4 class="modal-title" id="modal-label"&gt;关于&lt;/h4&gt; &lt;/div&gt; &lt;div class="modal-body"&gt; &lt;p&gt;谢谢浏览！&lt;/p&gt; &lt;/div&gt; &lt;div class="modal-footer"&gt; &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;好的&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 这段代码放置在body中任何地方均可以。tabindex=&quot;-1&quot;表示modal框脱离了全局html的tab切换页面，独立出来。aria-labelledby=&quot;modal-label&quot;该属性引用模态框的标题；属性 aria-hidden=&quot;true&quot; 用于保持模态窗口不可见，直到触发器被触发为止（比如点击在相关的按钮上）；data-dismiss=&quot;modal&quot;，是一个自定义的 HTML5 data 属性。在这里它被用于关闭模态窗口。 然后注意在模态框效果实现的地方还需要进行如下设置： 1&lt;li&gt;&lt;a href="#" data-toggle="modal" data-target="#about-modal"&gt;关于&lt;/a&gt;&lt;/li&gt; 保证data-target值与前面id值一致。 回到顶部1&lt;p class="pull-right"&gt;&lt;a href="#top"&gt;回到顶部&lt;/a&gt;&lt;/p&gt; 设置a的href属性为”#top”，当我们点击的时候，即可达到我们常见的回到页面顶部的效果。 总结本篇博文主要记录和总结了自己在练习制作基于Bootstrap的前端框架介绍网页时的心得和技巧，主要锻炼了自己应用bootstrap框架实践网页项目的能力，同时也加深了对bootstrap框架的理解。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中声明的提升]]></title>
      <url>%2F2017%2F01%2F04%2FJavaScript%E4%B8%AD%E5%A3%B0%E6%98%8E%E7%9A%84%E6%8F%90%E5%8D%87%2F</url>
      <content type="text"><![CDATA[前言本文主要记录和总结了JavaScript中关于声明提升的概念和相关注意事项。 提升（Hoisting）我们常习惯将var a = 2; 看作是一个声明，而实际上JS引擎并不这么认为。它将var a和a = 2当作两个单独的声明，第一个是编辑阶段的任务，而第二个是执行阶段的任务。 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理，可以将这个过程形象地想象成所有的声明（函数和变量）都会被“移动”到各自作用域的最顶端，这个过程称为提升(Hoisting)。 注意 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。 变量声明和函数声明会被提升，但是函数表达式声明不会被提升。 变量声明和函数声明都会被提升，但是当两者同时出现时，首先提升的是函数声明，其次才是变量声明。 下面给出具体的实例说明。（1）只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。123a = 2;var a;console.log(a); // 2 变量声明var a会被提升至作用域顶端，执行代码输出2。上述代码等效于123var a;a = 2;console.log(a); // 2 而对于下述代码，只会将变量声明提升，变量赋值不会提升，故输出undefined。12console.log(a); // undefinedvar a = 2; 上述代码等效于123var a;console.log(a); // undefineda = 2; （2）变量声明和函数声明会被提升，但是函数表达式声明不会被提升。12345foo();function foo()&#123; console.log(a); // undefined var a = 2;&#125; 上述代码中，函数声明会被提升，最终输出结果为undefined。上述代码等效于123456function foo()&#123; var a; console.log(a); // undefined a = 2;&#125;foo(); 函数声明会被提升，但是函数表达式声明不会被提升。对于下述代码中，函数表达式并不会被提升。123456foo(); //不是ReferenceError,而是TypeErrorbar(); //ReferenceErrorvar foo = function bar()&#123; console.log(a); // undefined var a = 2;&#125;; 上述代码等效于123456789var foo;foo(); //不是ReferenceError,而是TypeErrorbar(); //ReferenceErrorfoo = function ()&#123; var bar = ... self ... var a; console.log(a); // undefined a = 2;&#125;; 变量标识符foo被提升至作用域顶端，因此当执行foo()时，作用域中已经存在foo变量，作用域查找正常，故不是ReferenceError，但是由于采用函数表达式声明的方式创建函数foo()，函数表达式声明并不能被提升，故此时foo未被赋值，执行foo()时，foo()由于对undefined值进行函数调用而导致非法操作，因此会抛出TypeError。 不论是匿名函数表达式，还是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。var foo = function bar(){};会被解释成为1234foo = function ()&#123; var bar = ... self ... //...&#125; 因此，在执行bar()时，作用域查找失败，会抛出ReferenceError，而不是TypeError。 （3） 变量声明和函数声明都会被提升，但是当两者同时出现时，首先提升的是函数声明，其次才是变量声明。12345678910foo(); //1var foo;function foo()&#123; console.log(1);&#125;foo = function()&#123; console.log(2);&#125; 上述代码在执行过程中等效于123456789function foo()&#123; console.log(1);&#125;foo(); //1foo = function()&#123; console.log(2);&#125; 变量声明和函数声明都会被提升，但是当两者同时出现时，首先提升的是函数声明，其次才是变量声明。因此，函数声明function foo(){..}首先被提升。其次，提升变量声明foo,但是此时作用域中已经有foo变量，因此var foo;属于重复的声明，因此被忽略了。最后，foo = function(){..}属于函数表达式声明，不会被提升。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Web页面加载速度优化实战]]></title>
      <url>%2F2016%2F12%2F27%2FWeb%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98%2F</url>
      <content type="text"><![CDATA[前言本文主要介绍了关于优化Web页面加载速度方面的一些技巧与方法。 Web页面加载信息查看浏览器中打开控制台，在Network栏目下，可以获取Web页面的HTTP请求次数，传输的数据量大小，加载完成时间等信息。以百度首页为例，其web页面加载信息如下图所示，百度首页加载过程中，HTTP请求次数为48，数据传输量为37.5KB，加载完成耗时3.76s。 一般情况下，一个网页 4s 内加载不完，就会使用户失去耐心，造成网站流失很大一部分用户。移动端网页加载速度会稍慢于PC端。 优化图片图片在网络流量中占有很大的比重，因此，优化图片对于减少流量有着至关重要的作用。 合并小图片很多页面有很多小图标，一个一个加载就相当于一个一个请求。将这些小图片合并成一个大图片，用CSS控制显示范围，这样就只需要一个请求即可加载完所有小图片，瞬间就会减少很多网络请求。 优化图片格式很多图片没有经过优化直接上传到网页中会占用很多额外的流量。比如一张屏幕大小的截图，用截图工具直接截图后的大小大概有 1MB ，此时直接上传到网页中就直接占用了1MB流量，但其实我们完全可以只牺牲它40% 的质量换取缩小 10 倍的大小。 本章节参考资料：[1] 前端图片优化机制[2] 图片优化[3] 网站开发中，如何将一张图片压缩得更小？[4] WebP 探寻之路[5] A new image format for the Web - WebP 图片格式优化工具如下所示。 [1] PhotoShopPS中打开图片，“文件”菜单中选择“导出 -&gt; 存储为Web所用格式”。 虽然存在多种的图片格式，但是依据压缩方法不同，所有的图片都能进一步归类为两大类别：无损和有损。无损数据压缩保证了图像在没有任何品质和信息丢失的情况下重现，而有损数据压缩的结果就是可能造成品质和信息的丢失。在平面设计领域最主流的无损媒介格式包括GIF，PNG，以及TIFF，而JPEG是最主流的有损压缩的图形格式。 一般情况下jpg图片选择品质中即可，png 格式图片选择 png8 即可。但是需要注意的是，有透明背景的 png图片要选择 png24 ，否则透明背景中会出现白边。gif 图片选择 gif64 无仿色即可。 一般经过优化的图片大小至少会有 3倍之差，原图片越大，优化的结果会越好。 [2] 智图智图是腾讯ISUX前端团队开发的一个专门用于图片压缩和图片格式转换的平台，其功能包括针对png，jpeg，gif等各类格式图片的压缩，以及为上传图片自动选择最优的图片格式。同时，智图平台还会为用户转换一份webp格式的图片。此外，目前智图开放的API接口已被封装为gulp插件，方便用户接入在本地运行。iSparta效果同智图，可以通过npm安装。 [3] 其余图片压缩工具(如TinyPNG等)在此不具体给出，可以参考12款实用免费批量图片体积优化压缩工具。 使用CDN加载第三方资源通过CDN加载第三方资源，减少网站自身服务器的压力。例如，通过CDN加载jquery。1&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"&gt;&lt;/script&gt; 使用CDN储存静态资源一般网站90%的流量都用于静态资源的加载。除了用CDN加载第三方资源外，还可以将Web页面的静态资源（如图片，视频等）存储在CDN中，并在Web页面中引入，这样可以进一步减小服务器的开销，让服务器只专注于提供数据或者网页渲染服务。常用的CDN如]七牛云等。 合并压缩JS和CSS对多个JS文件或多个CSS文件进行合并，可以减少HTTP请求次数；对JS文件或者CSS文件进行压缩，可以减少页面加载时的数据传输量，缩短页面加载时间。 使用WebPack可以对JS和CSS文件进行合并与压缩。 代码优化本部分可以参考Yahoo - Best Practices for Speeding Up Your Web Site。 HTTP2 &amp; gzipHTTP2 是以 SPDY 为基础开发的。 SPDY 系列协议由谷歌开发，于 2009 年公开。它的设计目标就是降低 50% 的页面加载时间，所以 HTTP2 在很大程度也是为了优化页面加载时间，同时 HTTP2 支持多路复用，简单说就是所有的请求都通过一个 TCP 连接并发完成。 gzip是一种压缩网页的技术，当然压缩网页进行传输的代价就是给服务器增加一些压缩的负担，当然这种牺牲是值得的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的LHS和RHS]]></title>
      <url>%2F2016%2F12%2F15%2FJavaScript%E4%B8%AD%E7%9A%84LHS%E5%92%8CRHS%2F</url>
      <content type="text"><![CDATA[前言本文主要对JavaScript中的LHS和RHS进行解释介绍，并进行相应的举例说明。 LHS &amp; RHS概念分析 LHS与RHS是JavaScript引擎的两种查找类型，含义是赋值操作的左侧与右侧。 LHS(Left Hand Side)：对哪个赋值就对哪个进行LHS引用，可以理解为赋值操作的目标。 RHS(Right Hand Side)：需要获取哪个变量的值，就对哪个变量的值进行RHS引用，理解为赋值操作的源头。 可以简单的记忆为：一般在左边的需要被赋值，就是LHS引用；右边需要寻找到它的值，就是RHS引用。12345function foo(a)&#123; var b=a; rerurn a+b;&#125;var c=foo(2); 以上代码中有3个LHS与4个RHS，分析如下： var c中的c需要被赋值，在赋值操作的左侧，所以对c进行LHS引用 变量c需要被赋值，它的值是foo(2)，那么foo(2)的值是多少呢，需要查找foo(2)的值，在赋值操作的右侧，所以对foo(2)进行RHS引用 隐含赋值操作，将2传递给function foo(a){……}函数的参数a，a在赋值操作的左侧，对a进行LHS引用 var b=a;中，b需要被赋值，处在赋值操作的左侧，所以b进行的LHS，b的值将从a来，那么右侧的a的值从何而来呢？这就需要对赋值操作右侧的a进行RHS return a+b;中，需要找到a与b的值的来源，a与b都在赋值操作的右侧，才能得到a+b的值，所以对a与b都是进行RHS引用异常解释之所以区分LHS和RHS，只因为在遍历还没有声明（在任何作用域中都无法找到该变量）的情况下，这两种查询的行为是不一样的。 LHS和RHS查询都会在当前执行作用域中开始，如果有需要（即没有在当前作用域中查找到所需的标识符），就会向上级作用域继续查找目标标识符，直至抵达全局作用域，查找停止。 不成功的RHS引用会导致ReferenceError异常。不成功的LHS引用会导致自动隐式地创建一个全局变量（非严格模式下），该变量使用LHS引用的目标作为标识符，或者抛出ReferenceError异常（严格模式下）。 ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功了，但是对结果的操作是非法或者不合理的。查询到变量之后（已经表明作用域判别成功，不会出现ReferenceError异常），对这个变量进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用null或undefined类型值中的属性，那么引擎会抛出TypeError异常。 ES5中引入了“严格模式”。同正常模式（或称为宽松/懒惰模式相比），严格模式在行为上有很多不同，其中一个不同的行为则是严格模式禁止自动或隐式创建全局变量。因此，严格模式下，LHS查找失败后，不会自动隐式创建全局变量，只会抛出ReferenceError异常。 代码1 12345function foo(a)&#123; console.log(a+b); // b- RHS, a- RHS b = a; // b- LHS, a- RHS&#125;foo(2); 第一次对b进行RHS查询时，无法找到该变量，在其上级作用域（全局作用域）中依旧无法找到变量b，因此，引擎将抛出 ReferenceError异常。 若将代码1修改，在全局作用域中声明变量b，则在函数foo作用中对b进行RHS查找失败后，会自动向上一级的全局作用域中查找变量b。查找成功后，程序正常输出：12。123456function foo(a)&#123; console.log(a+b); // b- RHS, a- RHS b = a; // b- LHS, a- RHS&#125;var b = 10;foo(2); // 输出 12 若将上述代码再次修改，在全局作用域中声明变量b，并在局部作用域中声明变量b，则在函数foo作用中，使用局部变量b=3。全局作用域中，使用局部变量b=10。这种现象称为“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。123456789function foo(a)&#123; var b = 3; console.log(a+b); // b- RHS, a- RHS 输出：5 b = a; // b- LHS, a- RHS console.log("Global Scope: "+b); //2&#125;var b = 10;console.log("Global Scope: "+b); // 10foo(2); // 输出 12 代码212345function init(a)&#123; b = a + 3; &#125;init(2); console.log(b); //5 上述代码中，对b进行LHS。局部作用中查找变量b失败后，转向全局变量中查找变量b，依旧失败后，由于是LHS查询，因此会自动隐式创建一个全局变量b（这点与RHS不同）。因此，上述代码可以正常运行，并输出：5。 若将代码2修改，在局部作用域中声明变量b，则在全局作用域中执行console.log(b);,由于全局作用域中未声明变量b，因此将给出ReferenceError异常：ReferenceError: b is not defined.12345function init(a)&#123; var b = a + 3; &#125;init(2); console.log(b); //5 则在函数foo作用中对b进行RHS查找失败后，会自动向上一级的全局作用域中查找变量b。查找成功后，程序正常输出：12。 参考[1] javascript中的LHS与RHS]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[前端数据可视化开源库介绍]]></title>
      <url>%2F2016%2F12%2F02%2F%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%BC%80%E6%BA%90%E5%BA%93%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[前言数据可视化主要分为可视化工具（在线生成图类）以及可视化工具库。下面对前端中常用的数据可视化开源库进行介绍。 数据可视化开源库D3D3.js是目前 Web 端评价最高的 Javascript 可视化工具库，其实例丰富，提供了大量线性图和条形图之外的复杂图表样式（ Voronoi 图、圆形集群等），易于实现调试数据。且能够通过扩展实现任何可以想到的数据可视化效果。 D3.js与 jQuery 类似，D3 直接对 DOM 进行操作，这是它与其它可视化工具的主要区别所在：它会设置单独的对象以及功能集，并通过标准 API 进行 DOM 调用。 D3的缺点主要表现为学习曲线太过严苛（学习难度较高，学习成本较大），数据“生命周期”模式不够直观，要达到理想使用效果需要用户深入理解JavaScript。 E-chart E-chart由百度团队开发，实例较丰富，相对于d3来说，中文资料和文档较全，使用非常方便。 比较容易学习，上手较快。 E-chart基础图形都有，地图也有(扩展不多)，但缺少类似于D3的顶级图表绘制功能。 E-chart提供了很多参数接口，但是不能自己定义新的图形样式。infoVisinfoVis支持WebGL，可以和D3框架配合。infovis也提供了链式方法来操作DOM。但是，其demo和参考资料较少。CesiumCesium专注于地理数据可视化，可以在 Web 浏览器中绘制 3D/2D 地球。Cesium无需任何插件即可基于 WebGL 来进行硬件加速，并且具有跨平台、跨浏览器的特点。其本身基于 Apache 开源协议，支持商业及非商业项目。其缺点表现为可视化样式不太美观，速度较慢。参考资料如下所示。[1] Cesium[2] Cesium Github Page##Highcharts DemoHighcharts Demo 类库大小超轻量级，并且性能非常好，支持所有浏览器，但对于不同设备性能不太一样 价格初始价格对于个人开发者或者小团队来说价格很低 浏览器支持老式浏览器和现代浏览器都支持的非常好 个人支持一般的问题好解决，但是一旦遇到了关键问题，个人支持非常有限 支持图形支持图形相对于fusioncharts来说，比较少。和E-chart差不多，地图比E-chart好，但也只是静态展示。Fusioncharts 支持不同类型图表提供了90多种图表和965种地图自定义并且有实际例子。自定义图表类型非常简单，包含了很多直接可以使用的例子，并且拥有很大的库封装器和插件。 提供了官方的封装器和插件 浏览器和设备支持支持所有浏览器（IE6） 设备高级特性提供了很多高级特性，宏，可编辑图表 个人支持得到的支持非常快 体积非常重，如果是基于web的应用会成问题，但是App会好些 价格价格相对于前面有些贵 总结可跨平台、跨浏览器的 Flash 图表解决方案，但是不推荐使用，因为体积较大，十分笨重，官方demo加载都很慢AnyChart 基于 Flash/JavaScript(HTML5) 的图表解决方案 可以轻松地跨浏览器、跨平台工作 可以通过 XML 格式获取数据，该方式让开发人员非常灵活地控制图表上的每一个数据点，而当图表数据点数量偏大时，则可以采用 CSV 数据输入，减小数据文件大小和图表加载时间。 支持图形少，没有地图类 框架收费（交互式图表和仪表功能） DemoAnyChart Demo amCharts 图表样式美观 基础类图表齐全 可以免费使用，但是会有网址链接。如果想消除网址链接，需要付费。 地图类交互较少 DemoamChartsChart.js 简单、面向对象，为设计和开发者准备的图表绘制工具库 基于 Html5，响应式，支持所有现代浏览器 轻量级，且支持模块化，即开发者可以拆分 Chart.js ，仅引入自己需要的部分进入工程 支持的图表类型较少，只有6种基础图表类型 DemoChart.js DemoChartist.js 代码简洁，配置简单在工程中，Chartist.js 的 CSS 和 JavaScript 分离，因此代码比较简洁，在应用时配置流程十分简单。 支持响应式生成的是响应式图表，可以自动支持不同的浏览器尺寸和分辨率 图表种类较少仅仅支持6种基础图表类型 DemosChartist.js DemoGoogle Chart 非常容易修改使用的DOM 定义定制的方法非常简单 界面可用性及其来自GDC（Google developers console）的开源网络支持 官方demo较少 DemosGoogle Chart Demo 总结使用人数较少，资料基本都是10年以前的，不推荐使用Leaflet 可以同时良好运行于桌面和移动端的 Javascript 可交互地图库 使用 OpenStreetMap 的数据，并把可视化数据集中在一起 内核库很小，但由丰富的插件可以大幅拓展其功能，常常被用于需要展示地理位置的项目 DemoLeaflet DemoDygraphs 图表类型基本上都是线图 DemoDygraphs Demo 放大时间段查看数据点的交互很棒icharts iCharts 有交互元素，可以从 Google Doc、Excel 表单和其他来源中获取数据。 免费版只允许使用基本的图表类型 Demoicharts Demo Reference[1] 前端数据可视化开源库[2] 14款基于javascript的数据可视化工具[4] 13个Javascript框架：实现超棒数据可视化效果]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[明星介绍网站练习总结(三)]]></title>
      <url>%2F2016%2F11%2F27%2F%E6%98%8E%E6%98%9F%E4%BB%8B%E7%BB%8D%E7%BD%91%E7%AB%99%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%B8%89)%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作明星介绍网站demo过程中的一些心得和技巧，主要有三篇，这篇侧重于对表单部分实现的阐述和总结。 心得与技巧表单部分实现对于一个明星介绍网站来说，联系信息的公布还是比较重要的，所以很有必要构建一个联系表单。这里为了方便展示，我们不利用服务器端脚本来处理发送到后台的信息，而仅是创建一个html页面来进行调用来对提交信息的访客表示感谢。 页面设置这里会用的一些html5的标签，设置的表单联系信息主要包括访客的姓名、电子邮箱和想告诉作者的话等。具体代码实现如下： 123456789101112&lt;article&gt; &lt;h1&gt;联系作者&lt;/h1&gt; &lt;form method="post" action="thanks.html"&gt; &lt;label for="name"&gt;姓名：&lt;/label&gt; &lt;input type="text" id="name" placeholder="请输入您的名字" required /&gt; &lt;label for="email"&gt;邮箱：&lt;/label&gt; &lt;input type="email" id="email" placeholder="请输入您的邮箱" required /&gt; &lt;label for="textarea"&gt;留言:&lt;/label&gt; &lt;textarea placeholder="请输入您想告诉作者的话..." required&gt;&lt;/textarea&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/article&gt; 需要说明和注意的地方主要有以下几点： 整个表单需要放在form标签内，其中method是用来发送表单数据的http方法，这里使用的是post方法。action是规定当提交表单时向何处发送表单数据。这里补充引用w3school网站的一段话来说明一下post和get方法的选择问题。 如果希望获得最佳表单传输性能，可以采用 GET 方法发送只有少数简短字段的小表单。 一些服务器操作系统在处理可以立即传递给应用程序的命令行参数时，会限制其数目和长度，在这种情况下，对那些有许多字段或是很长的文本域的表单来说，就应该采用 POST 方法来发送。 如果你在编写服务器端的表单处理应用程序方面经验不足，应该选择 GET 方法。如果采用 POST 方法，就要在读取和解码方法做些额外的工作，也许这并不很难，但是也许你不太愿意去处理这些问题。 如果安全性是个问题，那么我们建议选用 POST 方法。GET 方法将表单参数直接放在应用程序的 URL 中，这样网络窥探者可以很轻松地捕获它们，还可以从服务器的日志文件中进行摘录。如果参数中包含了信用卡帐号这样的敏感信息，就会在不知不觉中危及用户的安全。而 POST 应用程序就没有安全方面的漏洞，在将参数作为单独的事务传输给服务器进行处理时，至少还可以采用加密的方法。 如果想在表单之外调用服务器端的应用程序，而且包括向其传递参数的过程，就要采用 GET 方法，因为该方法允许把表单这样的参数包括进来作为 URL 的一部分。而另一方面，使用 POST 样式的应用程序却希望在 URL 后还能有一个来自浏览器额外的传输过程，其中传输的内容不能作为传统a标签的内容。 label标签的使用，整个属性容易被忽略，但其实它可以通过for属性把一小段文本关联到表单的一个字段，可以增加可访问性，而尤其对于屏幕阅读器来说更是不可或缺。 HTML5的placeholder属性可以添加占位符文本，即在表单字段中显示默认的提示文本，会使用户觉得友好。还有HTML5提供的required属性，用于表示某个字段的值是必须填写不能留空的。 提交按钮的type属性得设置为submit，这样才能当用户点击提交按钮时触发提交表单的操作。 form对象文档中的每个表单元素其实都是一个form对象，每个form对象都有一个elements.length属性。这个属性返回表单中的包含的表单元素的个数。与childNodes.length相比较，后者是返回元素中国包含的所有节点的个数，而前者仅包含表单元素，所以两者是不同的。同理可知，form.elements是返回表单元素的数组，取得对应表单元素之后可以方便对之进行一些操作。 兼容旧版本对placeholder属性的不支持前面我们用placeholder属性添加了占位符文本，但是考虑到这是HTML5的特性，一些旧浏览器可能不会兼容，所以我们需要编写一个函数，使旧浏览器不兼容的时候也能达到相应效果。下面是函数的函数体： 1234567891011121314151617if (Modernizr.input.placeholder) return; for (var i=0; i&lt;whichform.elements.length; i++) &#123; var element = whichform.elements[i]; if (element.type == "submit") continue; if (!element.getAttribute('placeholder')) continue; element.onfocus = function() &#123; if (this.value == this.getAttribute('placeholder')) &#123; this.value = ""; &#125; &#125; element.onblur = function() &#123; if (this.value == "") &#123; this.value = this.getAttribute('placeholder'); &#125; &#125; element.onblur(); &#125; 首先我们检测浏览器是否支持placeholder属性，这里我们用到Modernizr，它是一个用来检测浏览器功能支持情况的 JavaScript 库。通过这个库我们可以检测不同的浏览器对于HTML5特性的支持情况。 然后我们通过前面说到的form对象的方法对表单元素进行循环遍历，并且跳过提交按钮，对它不做处理。 之后对原本元素里面的placeholder属性进行判断，如果有值则进行下面的操作。 最后添加两个事件处理函数，一个是onfocus事件，表单元素获得焦点时触发，一个是onblur事件，焦点移出表单字段时触发。这样我们就可以通过元素的value属性和className属性来对表单元素设置和移除默认值和样式了。 表单验证好的客户端验证可以帮助用户填好表单，避免提交未完成的表单，从而节省他们的时间。但是值得一提的是，服务器端的验证也是必不可少的，可以保护数据库和后台系统的安全，并不能被客户端验证所取代。 123function isFilled(field) &#123; return (field.value.length &gt; 1 &amp;&amp; field.value != field.placeholder);&#125; 这个函数检查了value属性的length属性，就能知道value中是不是没有任何字符，同时也比较value属性和placeholder属性的值，就可以知道用户是否对占位符文本没有改动，只有通过这两个验证才能返回true。 123function isEmail(field) &#123; return (field.value.indexOf("@") != -1 &amp;&amp; field.value.indexOf(".") != -1);&#125; 同样的，在对于电子邮件格式的检查上，我们至少需要确保表单字段中包含@和.这两个符号，才能使之通过验证，返回true。当然，我们也可以在css上或者是js上进行一些设置与处理，当无法通过验证时，样式发生改变或是出现一些提示性文字。 值得注意的地方是，我们可以通过onsubmit事件处理函数来添加验证行为，而且提交表单时的自动触发的submit事件，会被onsubmit事件所拦截，只有返回true的时候，才能使表单数据提交给服务器。 表单提交我们知道，Ajax技术的核心就是XMLHTTPRequest对象，它充当着浏览器的脚本(客户端)与服务器之间的中间人的角色。但是不同浏览器实现XMLHTTPRequest对象的方式不太一样。为了保证浏览器的兼容性，需要编写函数来获得不同类型或版本浏览器下的XMLHTTPRequest对象。 12345678910111213function getHTTPObject() &#123; if (typeof XMLHttpRequest == "undefined") XMLHttpRequest = function () &#123; try &#123; return new ActiveXObject("Msxml2.XMLHTTP.6.0"); &#125; catch (e) &#123;&#125; try &#123; return new ActiveXObject("Msxml2.XMLHTTP.3.0"); &#125; catch (e) &#123;&#125; try &#123; return new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123;&#125; return false; &#125; return new XMLHttpRequest();&#125; 前三个判断中主要是为了兼容不同IE版本浏览器中获得XMLHTTPRequest对象的方法。而其他浏览器中的相关方法主要就是new XMLHttpRequest(); 为了增加对用户的友好性，可以在Ajax请求刚启动时添加显示一个“正在载入”的图像，函数如下所示： 123456789function displayAjaxLoading(element) &#123; while (element.hasChildNodes()) &#123; element.removeChild(element.lastChild); &#125; var content = document.createElement("img"); content.setAttribute("src","images/loading.gif"); content.setAttribute("alt","Loading..."); element.appendChild(content);&#125; 具体做法是先把此dom元素里面的子元素全部删除，然后动态创建这个加载图像的元素。动态创建的过程主要是document.createElement()方法创建新元素，setAttribute()方法增加新元素的属性值，最后appendChild()方法添加入页面中。 接下来很重要的一步是将表单的值组织成URL编码的字符串，方法是循环遍历表单的每个字段，然后得到他们的名字和值，这里有个需要注意的地方，那些值中的一些特殊符号可能会带来歧义，从而引出传输的问题，所以需要用encodeURIComponent函数把值编码成URL安全的字符串，可以把有歧义的字符串转换成对应的ASCII编码。之后把数据用join函数联结即可 。具体代码如下：‘ 1234567var dataParts = []; var element; for (var i=0; i&lt;whichform.elements.length; i++) &#123; element = whichform.elements[i]; dataParts[i] = element.name + '=' + encodeURIComponent(element.value); &#125; var data = dataParts.join('&amp;'); 后面就是Ajax应用的一些正常步骤了： 1234567891011request.open('POST', whichform.getAttribute("action"), true); request.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); request.onreadystatechange = function () &#123; if (request.readyState == 4) &#123; if (request.status == 200 || request.status == 0) &#123; ...... request.responseText ...... &#125; request.send(data); return true; 最后还需要注意的一点是，有必要运用添加onsubmit事件来阻止默认的submit事件，通过发送ajax请求的成功与否来判断是否应该阻止表单继续提交，这样可以阻止浏览器重复提交表单。 总结这篇博文是我练习制作明星介绍网站demo总结的第三篇，侧重于对表单部分实现的阐述和总结。至此，关于这个demo练习的总结已经结束，总体来说，这个demo练习全面锻炼了我的html、css、javascript和ajax等前端技术，尤其是对于javascript dom的编程能力大大提升，收获颇丰。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[明星介绍网站练习总结(二)]]></title>
      <url>%2F2016%2F11%2F26%2F%E6%98%8E%E6%98%9F%E4%BB%8B%E7%BB%8D%E7%BD%91%E7%AB%99%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%BA%8C)%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作明星介绍网站demo过程中的一些心得和技巧，主要有三篇，这篇侧重于对javascript实现一些具体功能和效果的总结。 心得与技巧javascript编写与技巧主页幻灯片效果实现移动函数的实现我们想最终实现的效果就是在主页下方有个小窗口，当我们用鼠标放置在导航链接上时，可以在小窗口那里对应显示不同的小图片，并以动画的形式进行切换。 首先需要准备好素材，这里我们根据窗口的大小将5张小图片按照水平方向合成一张图片，方便之后的效果实现。 由于我们是通过移动图片的方式实现幻灯片变换的动画效果的，所以我们需要编写一个移动函数moveElement(elementID,final_x,final_y,interval)，其中elementID是待移动的元素，final_x和final_y是元素需要移动到的目标位置，而interval是每次移动的间隔时间。这个函数主要实现思路是通过不断比较元素当前位置与目标位置的距离，然后增大或减小元素当前的位置，使之向目标位置移动，直到到达目标位置为止。 这个函数编写看似简单，其实有很多需要注意和优化的地方： 首先需要进行对象检测，如以下代码所示： 123456if (!elem.style.left) &#123; elem.style.left = "0px"; &#125; if (!elem.style.top) &#123; elem.style.top = "0px"; &#125; 为了防止元素的left和top属性不存在，导致后面的操作无法进行出现错误，需要先进行检测，如果不存在则人为赋给它们‘0px’的值。 由于元素的left和top属性值是字符串形式，为了获得数据使之方便在后面进行距离的比较，需要通过parseInt()函数对字符串进行解析，从而返回整数值。 为了使图片移动和变换的动画效果感觉平滑和迅速，我们在比较当前位置和目标位置的距离时，当距离大的时候我们可以使一次移动的距离也变大，反之变小，具体实现我们可以使每次移动距离为当前位置与目标位置距离的十分之一，并通过Math.ceil()函数向上取整，使不到1px的时候移动1px，从而可以使元素到达目标位置处，如下所示： 12345if (xpos &lt; final_x) &#123; var dist = Math.ceil((final_x - xpos)/10); xpos = xpos + dist; &#125; ...... 在每次移动之后将移动后的位置赋给元素的left和top属性的时候，注意要将整数值再转回为字符串，并在后面加上`+“px”，如下所示： 1234if (xpos &lt; final_x) &#123; var dist = Math.ceil((final_x - xpos)/10); xpos = xpos + dist; &#125; 整体不断移动的实现主要是通过setTimeout()函数递归调用此移动函数，调用方法如下所示： 12var repeat = "moveElement('"+elementID+"',"+final_x+","+final_y+","+interval+")"; elem.movement = setTimeout(repeat,interval); 为了防止用户在链接之间快速移动鼠标导致动画效果的滞后，需要在每次移动开始前调用clearTimeout()函数清除积累在setTimeout队列里的事件。但这里有个值得注意的地方，为了可以在函数中一开始就可以调用movement变量，我们需要将之设置为被移动元素的属性，如下所示： 123if (elem.movement) &#123; clearTimeout(elem.movement); &#125; 实现链接与图片切换的同步效果为了实现链接与图片切换的同步效果，其实就是对导航里的链接进行循环遍历，绑定onmouseover()事件，然后得到当年链接的href属性值，与对应的页面名称相比较，来决定图片应该如何移动，如下所示： 12345678910var links = document.getElementsByTagName("a"); for (var i=0; i&lt;links.length; i++) &#123; links[i].onmouseover = function() &#123; var destination = this.getAttribute("href"); if (destination.indexOf("index.html") != -1) &#123; moveElement("preview",0,0,5); &#125; if (destination.indexOf("about.html") != -1) &#123; moveElement("preview",-150,0,5); &#125; 幻灯片窗口的相关css设置这里有以下三点需要注意的地方： 父元素的position属性得设置为relative相对定位，而子元素的position属性得设置为absolute绝对定位，这样才可以方便地使用移动距离。 父元素的overflow属性设置为hidden，使溢出的部分隐藏。 为保证小窗口是出现在动画之上的，我们还需要设置小窗口的z-index属性，这里可以设置为99。 内部链接设置在篮球技术页面，我们可以看到有两个内部链接，当点击链接的时候，下面的对应内容会显示出来，而正常的时候是隐藏的。这样可以节省页面空间，也对用户友好。 主要实现方法就是外层循环遍历给链接添加onclick()函数，监听哪个链接被触发事件，而在事件函数内部再循环遍历内容块，可以根据内容块的id与触发的链接的id属性一致来使之显示，即设置display属性为block即可。 考虑到局部变量作用域的问题，如果想在事件函数中调用其他函数中的局部变量，可以将这个局部变量赋给一个元素自己创建的自定义属性，而这个属性的作用域是持久存在的。 如果想从链接的href属性中获取对应部分的id，由于在这个属性的开头有“#”表示内部链接，所以我们可以使用字符串的split()方法。这个方法是根据传入的参数分隔符将一个字符串分成多个部分，得到一个数组，每个数组元素都是一个字符串。针对当前情况，我们可以编写如下代码实现： 1var sectionId = links[i].getAttribute("href").split("#")[1]; 表格样式的js实现在“主要经历“页面有个表格的形式来展示明星的主要经历，其中表格中主要有两种样式，一是斑马纹样式，即表格奇数行和偶数行背景底纹颜色不同，二是当鼠标移至表格某一行上的时候，那一行的背景底纹色也会随之改变。而这些均是通过javascript来实现的。 第一种样式主要通过stripeTables()函数实现，具体代码如下： 1234567891011121314if (!document.getElementsByTagName) return false; var tables = document.getElementsByTagName("table"); for (var i=0; i&lt;tables.length; i++) &#123; var odd = false; var rows = tables[i].getElementsByTagName("tr"); for (var j=0; j&lt;rows.length; j++) &#123; if (odd == true) &#123; addClass(rows[j],"odd"); odd = false; &#125; else &#123; odd = true; &#125; &#125; &#125; 其实就是获得table的dom元素之后，再循环遍历表格里面的行，用一个变量保存当前是奇数行还是偶数行的信息，如果是奇数行则添加奇数行的样式，如果是偶数行则改变变量布尔值，等待下一次循环。 第二种样式主要通过 highlightRows()函数实现，具体代码如下： 1234567891011if(!document.getElementsByTagName) return false; var rows = document.getElementsByTagName("tr"); for (var i=0; i&lt;rows.length; i++) &#123; rows[i].oldClassName = rows[i].className rows[i].onmouseover = function() &#123; addClass(this,"highlight"); &#125; rows[i].onmouseout = function() &#123; this.className = this.oldClassName &#125; &#125; 获得表格中行的dom元素数组之后，对之进行循环遍历，这里我们需要添加onmouseover和onmouseout两个鼠标事件，前者是鼠标移动到元素上触发，后者是鼠标从元素上移开时触发。这里有个需要注意的地方，就是为了保证在鼠标移开时可以回到原来的样式，所以提前需要用个变量保存原来的元素样式，在鼠标移开时再赋回去。 总结这篇博文是我练习制作明星介绍网站demo总结的第二篇，主要侧重于对javascript实现一些具体功能和效果的总结，我们可以发现，即使是一些看起来比较简单的功能和效果，里面也会有很多值得注意和优化的地方，或是包含一些小技巧。下一篇将主要针对这个demo的表单部分进行阐述和总结。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[明星介绍网站练习总结(一)]]></title>
      <url>%2F2016%2F11%2F25%2F%E6%98%8E%E6%98%9F%E4%BB%8B%E7%BB%8D%E7%BD%91%E7%AB%99%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作明星介绍网站demo过程中的一些心得和技巧，主要有三篇，这篇侧重于整体部分的设置总结。 心得与技巧html/css 结构和样式设置站点和页面结构站点结构主要由图片文件、css文件、js文件和html文件组成，其中html文件除了主页index.html之外，根据内容划分的需要，还有另外的5个html文件，共同组成了这个明星介绍网站的基本结构。其中每个html页面的头部区域有相似之处，均由一张大的图片logo和导航区域组成，下面的页面内容部分则根据需求各有特色。值得注意的是，这里的标签我们运用html5的元素(如header、nav、article等)。 css设置css文件主要由reset.css和index.css两个css文件组成。reset.css文件主要是为了重设浏览器标签的样式表。因为浏览器的品种很多，每个浏览器的默认样式也是不同的。在切换页面的时候，浏览器的默认样式往往会给我们带来麻烦，影响开发效率。所以解决的方法就是一开始就将浏览器的默认样式全部去掉，更准确说就是通过重新定义标签样式。“覆盖”浏览器的CSS默认属性。如下面这种： 123456789section, header, article, nav &#123; display: block;&#125;* &#123; padding: 0; margin: 0;&#125;...... 其中设置那些html5的标签为块状元素也是为了考虑到兼容性，如果浏览器不支持html5的情况下，也不会对布局造成大的影响。有些css设置技巧在前面的博文中已有相关叙述。 javascript编写与技巧一些通用函数的编写如果想要在文档完全加载之后用到某个函数，则先需要用到addLoadEvent函数： 1234567891011function addLoadEvent(func) &#123; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = func; &#125; else &#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125;&#125; 这个函数可以看成是共享onload事件，为了可以实现在页面加载完毕时可以执行任意多个函数的效果，先创建匿名函数来容纳旧函数和新函数。具体操作如下： 把现在传入的事件处理函数存入一个变量中。 判断如果这个处理函数上还没有绑定任何函数，则把新函数添加给它 如果如果这个处理函数上已经绑定一些函数了，则把新函数增加到现有指令的末尾。这样可以把页面加载完毕时执行的函数创建为一个队列。 我们知道在javascript中只有自带的insertBefore函数，可以把节点插入到另一个节点之前，而没有函数可以把节点插入到一个节点之后。而这个需求又是很常见的，所以编写一个insertAfter函数还是很有必要的。 12345678function insertAfter(newElement,targetElement) &#123; var parent = targetElement.parentNode; if (parent.lastChild == targetElement) &#123; parent.appendChild(newElement); &#125; else &#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; 具体操作如下： 通过parentNode属性找到目标节点的父节点。 通过lastChlid属性判断最后一个子节点是不是目标节点。 如果最后一个子节点是目标节点，则直接用appendChild方法添加待插入节点即可。 如果不是的话，则需要运用nextSibling属性和insertBefore方法，将待插入节点放在紧邻目标节点的下一个兄弟节点之前即可。 还有一个非常常用的函数是给一个元素追加新的class样式，我们给这个函数起名为addClass函数 12345678910function addClass(element,value) &#123; if (!element.className) &#123; element.className = value; &#125; else &#123; newClassName = element.className; newClassName+= " "; newClassName+= value; element.className = newClassName; &#125;&#125; 具体操作如下： 首先得判断原来的元素中有没有class样式，如果没有的话，直接将新的class通过元素的className属性赋给它即可。 如果已有class样式，则通过js中连接字符串的‘+’运算符，将原来的class样式加上一个空格字符串和新的class样式，再将新的字符串赋给元素的className属性即可。 页面切换时的设置技巧使当前页面导航链接突出显示首先我们会在css样式表中添加一个‘here’类，并给它设置相应的样式，作为当前界面突出显示的导航链接样式。然后重点就是在如何将这个样式放在当前界面的导航元素那里，为此，我们编写函数highlightPage()来实现这个功能。 首先进行对象检测，判断需要用到的DOM方法和一些元素是否存在，具体如下所示： 123456if (!document.getElementsByTagName) return false; if (!document.getElementById) return false; var headers = document.getElementsByTagName('header'); if (headers.length == 0) return false; var navs = headers[0].getElementsByTagName('nav'); if (navs.length == 0) return false; 这里有个地方需要注意一下，就是getElementsByTagName这个方法和getElementById不一样，它得到的是一个数组，即使只有一个元素，也是通过数组的[0]来得到。 然后获得所有导航链接，并对之进行循环遍历： 12var links = navs[0].getElementsByTagName("a"); for (var i=0; i&lt;links.length; i++) &#123; 下面是最重要的判断链接是否对应当前页面的方法，这里采取的是比较当前链接的URL和当前页面的URL，具体如下： 1234 var linkurl;linkurl = links[i].getAttribute("href");if (window.location.href.indexOf(linkurl) != -1) &#123; links[i].className = "here"; 这里通过getAttribute方法获取元素的href属性值，得到当前页链接的URL，然后通过window.location.href方法获取当前页面的URL，而比较方法是通过字符串的indexOf方法，这个方法返回传入参数的子字符串在调用方法的字符串里第一次出现的位置。如果没有匹配到则返回-1。通过判断是否匹配到就能得到链接是否对应当前页面的信息。得到之后赋予对应的class即可。 切换页面应用样式为了方便地在切换页面的时候可以应用不同的样式，可以利用js在上面这个函数中给每个页面的body元素添加id属性。具体如下： 12var linktext = links[i].lastChild.nodeValue.toLowerCase(); document.body.setAttribute("id",linktext); 这里可以在遍历的时候，找到当前a标签里面的最后一个节点，是文本节点，并通过nodeValue属性取得链接文本的值。为了设为id属性，再用toLowerCase()方法转换为小写，最后通过setAttribute()方法将body的id属性设为此值即可。 总结这篇博文是我练习制作明星介绍网站demo总结的第一篇，主要侧重于整体部分的总结和技巧说明，下一篇将侧重于对javascript实现一些具体功能和效果的总结。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中作用域问题]]></title>
      <url>%2F2016%2F11%2F17%2FJavaScript%E4%B8%AD%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[前言这篇文章主要记录和总结了关于JavaScript中作用域的一些问题。 词法作用域 作用域共有2种主要的工作模型。第一种是词法作用域，这是最为普遍的，被大多数编程语言采用。第二种是动态作用域，使用较少，诸如Perl，Bash脚本等语言在使用。JavaScript使用词法作用域。 词法作用域词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。 欺骗词法JavaScript中有2个机制可以“欺骗”（或修改）词法作用域：eval()和with(expression){statement}。二者的副作用都将导致引擎无法在编译时对作用域查找进行优化，导致性能降低，故不推荐使用。 with(expression){statement}本质上是通过将一个对象的引用当做作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建一个新的词法作用域（程序运行时）。参考 Mozilla Develop Network Website 了解更多。 用with从对象中创建出的作用域仅在with声明中有效，在外部作用域中无效。1234567891011121314151617181920function foo(obj)&#123; with(obj)&#123; a = 2; &#125;&#125;var o1 = &#123; a:3 &#125;;var o2 = &#123; b:2&#125;;foo(o1);console.log(o1.a); //2foo(o2);console.log(o2.a); //undefinedconsole.log(a); //2 但是这样会将a泄露至全局作用域中 执行foo(o1)时，a=2赋值操作找到了o1.a并将2赋值给它，这在后面的console.log(o1.a)中可以体现。而当执行foo(o1)时，o2传递进去，o2并没有a属性，因此不会创建这个属性，o2.a保持undefined；此时，在o2的作用域，foo(..)的作用域和全局作用域都没有找到标识符a，因此当执行a=2时，自动创建了一个全局变量（非严格模式下）。with这种将对象及其属性放进一个作用域并同时分配标识符的行为很让人费解。 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。 函数作用域和块作用域JavaScript中函数的定义函数声明（function statement）（函数语句） function name([param[, param[, … param]]]) { statements } 这是最常见的一种函数定义方式，使用function标识符和函数名创建。具有函数名的函数成为具名函数，没有函数名的函数成为匿名函数。123function double(x)&#123; return 2 * x; &#125; ####3.1.2 函数表达式 (function expression) function [name] ([param] [, param] […, param]) { statements }`函数名name可以省略。当省略函数名的时候，该函数就成为了匿名函数。 函数表达式（function expression）非常类似于函数声明（function statement），并且拥有几乎相同的语法。函数表达式与函数声明的最主要区别是函数名称（function name），在函数表达式中可忽略它，从而创建匿名函数（anonymous functions）。 123var x = function(y) &#123; return y * y;&#125;; 命名函数表达式（Named function expression）如果你想在函数体内部引用当前函数，则需要创建一个命名函数表达式。然后函数名称将会（且只会）作为函数体（作用域内）的本地变量。这样也可以避免使用非标准的 arguments.callee属性。1234567var math = &#123; 'factorial': function factorial(n) &#123; if (n &lt;= 1) return 1; return n * factorial(n - 1); &#125;&#125;; Function构造函数 new Function (arg1, arg2, … argN, functionBody)1var double = new Function("x", "return 2 * x;"); 使用Function构造函数，把参数列表和函数体都作为字符串传入。 Tip 不推荐使用 Function 构造函数创建函数,因为它需要的函数体作为字符串可能，这样会阻止一些JS引擎优化，也会引起其他问题。 JavaScript中匿名函数（Anonymous Function）匿名函数（Anonymous Function）常见的创建方式有2种。 函数表达式 (function expression)（同3.1.2章节） 123var x = function(y) &#123; return y * y;&#125;; 立即执行函数表达式 ( function( ){ } )( ) or ( function( ){ } ( ) )( function( ){ } )( ) 和 ( function( ){ } ( ) ) 这两种方式在功能上是一样的，根据个人喜好选择一种方法即可。 1234function (a,b) &#123; console.log(a+b); &#125;foo(2,3); //5 上述代码，声明了foo函数，foo存在于全局作用域中，可以认为是“污染”了全局作用域。函数foo()创建之后，必须显示地通过函数名调用才能执行这个函数。 若将上述代码修改为如下所示的立即执行表达式，函数名foo只能在( function( ){ ... } )( ) 中的...作用域中存在，并不会“污染”全局作用域。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。 下述代码中，函数在创建完成后会自动地执行。这种模式成为IIFE，代表立即执行函数表达式（Immediately Invoked Function Expression）。 区分函数声明和函数表达式的最简单的方法是看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明的位置）。如果function是声明中的第一个词，那么就是函数声明。否则，就是一个函数表达式，例如，( function( ){ ... } )( ) 中function 前的 (表明该语句是一个函数表达式。 12345678(function (a,b) &#123; console.log(a+b); //5&#125;)(2,3); // 或者(function foo (a,b) &#123; console.log(a+b); //5&#125;)(2,3); 块作用域（block-level scope）大多数类C语言和JavaScript都支持函数作用域；大多数类C语言也支持块级作用域，但是JavaScript并不支持块级作用域。如下代码所示。1234567891011#include &lt;stdio.h&gt; void main() &#123; int i=2; i--; if(i) &#123; int j=3; &#125; printf("%d/n",j); //Error: use an undefined variable:j&#125; C语言具有块级作用域，变量j是在if语句中创建的，因此，在if(){...}之外访问变量j，会出现Error: use an undefined variable:j。 块级作用域：任何一对花括号中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。 而对于下述JavaScript代码，由于JS不支持块级作用域，因此，变量i的作用域是整个test()函数的作用域，调用alert(i)时会正常输出3。（for循环语句并没有创建一个块级作用域）123456functin test()&#123; for(var i=0;i&lt;3;i++)&#123; &#125; alert(i); //3&#125; test(); 为了使JS支持块级作用域，可以采用如下的方法： 采用闭包，编写立即执行函数表达式(function () { })();，借助函数作用域”实现”块级作用域的效果。12345678function test()&#123; (function ()&#123; for(var i=0;i&lt;4;i++)&#123; &#125; &#125;)(); alert(i); //Uncaught ReferenceError: i is not defined&#125; test(); 执行上述代码，由于for语句块放到了一个闭包之中，采用了立即执行函数表达式，当该函数调用完后，变量会被撤销。因此，调用alert(i)时会输出Uncaught ReferenceError: i is not defined。 使用with &amp; try/catch &amp; let &amp; const语句创建块级作用域。 本章节参考资料如下。[1] JavaScript的作用域和块级作用域概念理解 let和const 创建块作用域变量ES6中引入了let和const来创建块作用域变量，其中const创建的变量的值不能修改，否则会引起错误。1234567891011if(1)&#123; const num1 = 4; let num2 = 2; var num3 = 3; num1 = 1; //error num2 = 8;&#125;console.log(num1); //ReferenceErrorconsole.log(num2); //ReferenceErrorconsole.log(num3); //3 上述代码中，使用var创建的变量具有全局作用域，使用let和const创建的变量具有块作用域。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript中的闭包与this]]></title>
      <url>%2F2016%2F11%2F04%2FJavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%E4%B8%8Ethis%2F</url>
      <content type="text"><![CDATA[前言本文主要对JavaScript中的闭包与this这两个概念进行较为详细地阐述。 闭包闭包简介 当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。本质上，无论何时何地，如果将（访问它们各自词法作用域的）函数当做第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器，事件监听器，Ajax请求，跨窗口通信，Web Workes或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 闭包由两部分构成：函数和创建该函数的环境。即闭包 = 函数 + 创建该函数的环境。 ###5.1 循环和闭包12345for(var i=0;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i); &#125;,1000);&#125; 执行上述代码，并不会输出数字1~5，而是会以每秒一次的频率输出5次数字6。 延迟函数的回调会在循环结束时才执行。setTimeout()函数遵循如下机制：setTimeout是在任务队列结束的时候开始计时的，如果前面有进程没有结束，那么就等到它结束后在开始计时。 上述代码中，setTimeout()函数位于for循环中，for循环没有结束时，setTimeout()中的回调函数并不会执行。当for循环结束时，变量i的值为6。此时，setTimeout()函数前面的进程已经结束，可以执行回调函数，因此，会输出5个数字6。 若将上述代码修改为如下所示的代码，IIFE（Immediately Invoked Function Expression）会通过声明并立即执行一个函数来创建作用域。1234567for(var i=0;i&lt;=5;i++)&#123; (function()&#123; setTimeout(function timer()&#123; console.log(i); &#125;,1000); &#125;)(); &#125; 执行该代码，依旧会在for循环结束之后输出5个数字6。这是因为虽然每个延迟函数都会将IIFE每次迭代中创建的作用域封闭起来，但是IIFE创建的作用域虽然是封闭的，但只是一个空的作用域，并不能为我所用。因此，需要向该作用域中添加一些实质内容，才能为我使用。再次将代码修改为12345678for(var i=0;i&lt;=5;i++)&#123; (function()&#123; var j = i; setTimeout(function timer()&#123; console.log(j); &#125;,1000); &#125;)(); &#125; 上述代码可以正常工作，并每秒输出一个数字，数字为1~5。上述代码中，将for循环中的变量i传递至IIFE创建的封闭作用域中，会输出如期的结果。当然，上述代码也可以修改为如下所示的代码， 效果是一样的。1234567for(var i=0;i&lt;=5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j); &#125;,1000); &#125;)(i); &#125; 总结上述代码修改过程，可以发现，当使用IIFE在每次迭代时创建一个新的非空的封闭的作用域时，可以输出如期的结果。也就是说，每次迭代都需要创建一个块作用域。 JS中let声明可以用来劫持块作用域，并且在这个块作用域中声明一个变量。 本质上这是将一个块转换成一个可以被关闭的作用域。123456for(var i=0;i&lt;=5;i++)&#123; let j = i; //闭包的块作用域 setTimeout(function timer()&#123; console.log(j); //1 2 3 4 5 &#125;,1000); &#125; 上述代码中使用let声明了变量j，let创建了一个块作用域，程序输出为1~5，和用IIFE的方式效果一样。 此外，若在for循环头部中使用let声明，还会产生一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会被声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。12345for(let i=0;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i); //1 2 3 4 5 &#125;,1000); &#125; 关于this this既不指向函数自身也不指向函数的词法作用域。 当一个函数被调用时，会创建一个执行上下文（或活动记录）。这个执行上下文会包含函数在哪里被调用（调用栈），函数的调用方式，传入的参数等信息。this就是这个执行上下文的一个属性，会在函数执行的过程中用到。 this实际上是在函数调被调用时发生绑定的，并不是在编写时候绑定的，它的上下文取决于函数调用时的各种条件。this的绑定与函数声明的位置没有任何关系，只取决于函数调用的方式（调用位置或调用方法）。this 绑定规则 默认绑定 隐式绑定1234567891011function foo()&#123; console.log(this.a);&#125;var obj = &#123; a:2; foo:foo;&#125;;var bar = obj.foo; //函数别名var a = "lbs0912";bar(); // lbs0912 虽然bar是obj.foo的一个引用，但实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，故this使用了默认绑定，this.a = a = window.a (global scope)，而不是·obj.a·。 显示绑定硬绑定是显示绑定的一种。使用硬绑定之后就无法使用隐式绑定或者显示绑定来修改this。 new绑定如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。对于this绑定来说，称为new绑定。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript创建标记片段充实内容实践]]></title>
      <url>%2F2016%2F10%2F25%2FJavaScript%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0%E7%89%87%E6%AE%B5%E5%85%85%E5%AE%9E%E5%86%85%E5%AE%B9%E5%AE%9E%E8%B7%B5%2F</url>
      <content type="text"><![CDATA[前言本文主要记录了运用JavaScript创建标记片段来充实文档内容的一些实践和注意事项。 充实文档内容8.1 HTML，XHTML和HTML5对于标记而言，无论选用 HTML，XHTML，还是HTML5，都必须和DOCTYPE声明保持一致。 XHTML对标记有着更严格地要求，这样可以督促我们写出更严清晰的文档。而HTML对标签和属性的要求则没有这么严格，例如，HTML中既允许使用大写字母（如&lt;DIV&gt;）,也允许使用小写字母（如&lt;div&gt;）。 推荐使用XHTML，其优点包括 XHTML中要求所有的标签名和属性名必须使用小写字母。 XHTML中所有标签都必须闭合——对诸如&lt;img&gt;和 &lt;br&gt;标签也不例外。而HTML中允许部分标签省略结束标签——比如可以省略&lt;/p&gt;和&lt;/li&gt;标签等。为了与早期的浏览器保持兼容，应该在反斜杠字符的前面保留一个空格，例如&lt;br /&gt;。 In HTML, the &lt;br&gt; tag has no end tag.In XHTML, the&lt;br&gt; tag must be properly closed, like this: &lt;br/&gt;. 若使用XHTML，则其DOCTYPE的写法为1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; 若采用HTML5方案，则只需书写1&lt;!DOCTYPE html&gt; 即可，该声明同样支持HTML和XHTML。 8.2 快捷键设置HTML中，accesskey属性可以把一个元素（如链接）与键盘上的某个特定的按键关联在一起，起到键盘快捷方式的作用。 一般来说，windows系统的浏览器中，快捷键的用法是Alt + 特定按键。Mac系统的浏览器里，快捷键的用法是Ctrl + 特定按键。 1&lt;a href="http://liubaoshuai.top" accesskey="1"&gt;My Blog&lt;/a&gt; 上述代码中，对链接绑定了快捷键。在浏览器访问中，windows下只需按下Alt + 1，就可访问该链接。 ###8.3 lastChild V.S. lastElementChild The lastChild property returns the last child node of the specified node, as a Node object. The returned node object may be an element node, a text node or a comment node. The lastElementChild property returns the last child element of the specified element. The returned node object should be an element node, ignores a text node and a comment node. The difference between lastChild and lastElementChild, is that lastChild returns the last child node as an element node, a text node or a comment node (depending on which one’s last), while lastElementChild returns the last child node as an element node (ignores text and comment nodes). — W3 School Note: Whitespace and line breaks inside elements is considered as text, and text is considered as nodes。（空格和换行符会被当做文本节点，在使用lastChild时，可能会将空格和换行符当做文本节点返回。） 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;p&gt;Example list:&lt;/p&gt; &lt;ul id="myList"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Click the button to get the HTML content of the list's last child node.&lt;/p&gt; &lt;button onclick="myFunction()"&gt;Try it&lt;/button&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Whitespace inside elements is considered as text, and text is considered as nodes.&lt;/p&gt; &lt;p&gt;If you add whitespace before the closing UL element, the result will be "undefined".&lt;/p&gt; &lt;p id="demo"&gt;&lt;/p&gt; &lt;script&gt; function myFunction() &#123; var list = document.getElementById("myList").lastChild.innerHTML; document.getElementById("demo").innerHTML = list; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 上述代码中，将获取&lt;ul&gt;列表中的最后一个元素，然后将其显示出来。由于代码中&lt;/li&gt;和&lt;/ul&gt;之间有一个换行符，因此，lastChild返回的是该换行符，故最终结果会显示undefined。解决方案： 方法1：将lastChild替换为lastElementChild 方法2：去掉&lt;/li&gt;和&lt;/ul&gt;之间的换行符或空格，采用如下代码格式。1&lt;ul id=&quot;myList&quot;&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Tea&lt;/li&gt;&lt;/ul&gt; 综上案例，在使用lastChild和lastElementChild时，一定要注意返回节点的类型，注意二者之间的区别。下面是一个来自StackOverflow 的代码实例，编写者本意是每次点击按钮，将删除一个列表元素。但是由于采用lastChild时，换行符会被当做文本节点返回。因此，在第一次点击时候，只会删除换行符。在第2次，第3次……点击按钮时，才会正常删除列表元素。 12345678&lt;ul id="list"&gt; &lt;li&gt;List item 1&lt;/li&gt; &lt;li&gt;List item 2&lt;/li&gt; &lt;li&gt;List item 3&lt;/li&gt; &lt;li id="child"&gt;List item 4&lt;/li&gt; &lt;li&gt;List item 5&lt;/li&gt;&lt;/ul&gt;&lt;input type="button" value="Delete last"&gt; 123456document.getElementsByTagName('input')[0].onclick = function () &#123; 'use strict'; var list = document.getElementById('list'), item = list.lastChild; list.removeChild(item); window.alert("Removed");&#125;; 主要参考资料：[1] StackOverflow[2] MDN[3] W3 School 几乎所有的浏览器都支持lastChild属性，但是一些高版本浏览器才支持lastElementChild属性。 Accroding to the above figure, this lastElementChild property is unsupported prior to IE9, so the following snippet can be used to add support to IE8:12345678910// Source: https://github.com/Alhadis/Snippets/blob/master/js/polyfills/IE8-child-elements.jsif(!(&quot;lastElementChild&quot; in document.documentElement))&#123; Object.defineProperty(Element.prototype, &quot;lastElementChild&quot;, &#123; get: function()&#123; for(var nodes = this.children, n, i = nodes.length - 1; i &gt;= 0; --i) if(n = nodes[i], 1 === n.nodeType) return n; return null; &#125; &#125;);&#125; 上述代码来自Github。 也可以采用如下的方法，来实现lastElementChild的效果：在getElementsByTagName()中使用通配符*获取一个包含所有元素节点的数组（获取的是元素节点，不包括文本节点或者注释节点），然后输出改数组的最后一个元素。12345678910&lt;p&gt;Example list:&lt;/p&gt; &lt;ul id="myList"&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;Click the button to get the HTML content of the list's last child node.&lt;/p&gt; &lt;button onclick="myNewFunction()"&gt;Try it&lt;/button&gt; &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Whitespace inside elements is considered as text, and text is considered as nodes.&lt;/p&gt; &lt;p&gt;If you add whitespace before the closing UL element, the result will be "undefined".&lt;/p&gt; &lt;p id="demo"&gt;&lt;/p&gt; 12345678function myNewFunction() &#123; var list = document.getElementById("myList"); var childAllNodes = list.getElementsByTagName("*"); console.log(childAllNodes[childAllNodes.length-1].nodeName); //LI console.log(childAllNodes[childAllNodes.length-1].nodeType); //1 console.log(childAllNodes[childAllNodes.length-1].innerHTML); //Tea console.log(childAllNodes[childAllNodes.length-1].childNodes[0].nodeValue); //Tea &#125; 需要注意的是： parentNode.getElementsByTagName(*)获取的是一个包含所有元素节点的数组（获取的是元素节点，不包括文本节点或者注释节点） nodeName返回的节点名称都是大写，如LI，DIV等 元素节点的nodeValue值是null。因此，description.nodeValue的值为null。若要返回元素节点中的文本，需要执行element.childNodes[0].nodeValue语句。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript动态创建标记技术]]></title>
      <url>%2F2016%2F10%2F20%2FJavaScript%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E6%A0%87%E8%AE%B0%E6%8A%80%E6%9C%AF%2F</url>
      <content type="text"><![CDATA[前言本篇博文记录总结了如何通过创建新元素和修改现有元素来改变网页结果。主要包括传统技术和DOM方法这两种。 动态创建标记本章节将讲述如何通过创建新元素和修改现有元素来改变网页结果。主要包括传统技术和DOM方法这两种。 传统技术： document.write() , innerHTML DOM技术： createElement, createTextNode, appendChild, insertBefore(在任何时候，标准的DOM都可以用来替代innerHTML)传统技术 document.write() 1document.write("&lt;p&gt;Demo&lt;/p&gt;"); innerHTML 123var testdiv = document.getElementById("testdiv");testdiv.innerHTML = "Div Content";testdiv.innerHTML = "&lt;p&gt;ChildNode Demo&lt;/p&gt;"; DOM技术 createElement ： 创建一个元素节点（不能创建文本节点），但是该节点并未插入DOM树中，是游历于文档之外的。 appendChild ：把新创建的节点插入到文档的DOM树中。 createTextNode： 创建一个文本节点（不能创建元素节点），但是该节点并未插入DOM树中，是游历于文档之外的。 parentNode.insertBefore(newNode,referenceNode)：将一个新节点插入到参考节点之前，这两个节点都是parentNode的子节点。1234567891011121314151617181920var parentNode = document.getElementById("content");var para = document.createElement("p");var txt1 = document.createTextNode("This is");para.appendChild(txt1); //&lt;p&gt;This is &lt;/p&gt;var emphasis = document.createElement("em");var txt2 = document.createTextNode(" my");emphasis.appendChild(txt2);para.appendChild(emphasis); //&lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; &lt;/p&gt;parentNode.appendChild(para);var txt3 = document.createTextNode(" node");para.appendChild(txt3); //&lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; node&lt;/p&gt;var head1 = document.createElement("h1");var txt4 = document.createTextNode("Head 1");head1.appendChild(txt4); //&lt;h1&gt;Head 1&lt;/h1&gt;parentNode.insertBefore(head1,para); //!! 上述代码，将创建一个如下所示的HTML文档。注意上述代码中最后一句中insertBefore的用法（将一个新节点插入到父节点中指定的子节点的前面，新插入的节点是父节点的子节点）。1234&lt;div id="content"&gt; &lt;h1&gt;Head 1&lt;/h1&gt; &lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; node&lt;/p&gt;&lt;/div&gt; insertAfter()DOM本身并没有提供insertAfter()方法，但是可以借助于insertBefore()和appendchild()方法实现该insertAfter()方法。 parentElement.insertBefore(newElement,targetElement); 12345678910function insertAfter(newElement,targetElement)&#123; var parent = targetElement.parentNode; if(parentNode.lastChild == targetElement)&#123; parent.appendChild(newElement); &#125; else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125;&#125; 上述代码中，nextSibling表示下一个兄弟节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript DOM学习笔记]]></title>
      <url>%2F2016%2F10%2F08%2FJavaScript%20DOM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[前言这篇博文主要记录了学习JavaScript过程中关于DOM的部分心得与总结。 DOM学习总结 5个常用的DOM方法：getElementById,getElementsByTagName,getElementsByClassName,getAttribute和setAttribute。 getElementById()返回的是一个具有指定ID属性值的元素节点对应的对象，是一个单一对象，因此getElementById中元素Element为单数。 getElementsByTagName()和getElementsByClassName()方法返回的是对象数组，因此，Elements为复数。getElementByTagName(“*”) getElementByTagName(&quot;*&quot;)中使用*通配符，表示获取文档中的全部元素节点。通配符*必须放在用引号中，来和乘法符号区别。例如，要想知道文档中有多少个元素节点，可以使用 1var length = document.getElementByTagName("*").length; getElementByTagName(&quot;tag&quot;) 返回的是一个对象数组，具有数组的length属性，若采用typeof返回其类型，其结果为object`。若针对HTML文档 12345&lt;ul&gt; &lt;li&gt; A &lt;/li&gt; &lt;li&gt; B &lt;/li&gt; &lt;li&gt; C &lt;/li&gt;&lt;/ul&gt; 其JS代码为123456789var myArray = document.getElementsByTagName("li"); //[li,li,li]var length = myArray.length; //3for(var i=0;i&lt;length;i++)&#123; console.log(myArray[i]); // &lt;li&gt; A &lt;/li&gt; &lt;li&gt; B &lt;/li&gt; &lt;li&gt; C &lt;/li&gt;&#125;console.log(myArray); //[li,li,li]console.log(typeof myArray); //objectconsole.log(typeof myArray[0]); //object 则执行结果为 对于上述代码，即使只有一个&lt;li&gt;列表，返回的也是一个对象数组，是object对象，其length为1，其中每一个元素都是对象（这里只有一个元素）。 getElementByTagName(className1 className2)getElementByTagName(className1 className2)中，若传入多个类名称，类名成之间以空格隔开，而不是逗号隔开。 getElementById, getElementsByTagName和getElementsByClassName的组合使用getElementById,getElementsByTagName和getElementsByClassName三者间可以组合使用，共同对元素节点进行选取。例如，获取id为demo且class为content的元素节点，其代码如下所示。12var demo = document.getElementById("demo");var final = demo.getElementsByClassName("content"); getAttribute和setAttribute12345678//---&lt;div id="demo"&gt;Demo&lt;/demo&gt;//---var demo = document.getElementById("demo");console.log(demo);console.log(demo.getAttribute("id"));demo.setAttribute("id","test");console.log(demo.getAttribute("id")); 对于上述代码，使用getAttribute()可以获取元素的属性，使用setAttribute()可以对元素属性进行设置。 通过setAttribute()方法对文档做出的修改，将使得文档在浏览器窗口里的显示效果和/或行为动作发生相应的变化，但在通过浏览器的view source（查看源代码）选项去查看文档的源代码时看到的仍将是原来的属性值——也就是说，setAttribute()方法做出的修改不会反映在文档本身的源代码里。这种“表里不一”的现象源自DOM的工作模式：先加载文档的静态内容，再以动态方式对它们进行刷新，动态刷新不影响文档的静态内容。这正是DOM的真正威力和诱人之处：对页面内容的刷新不需要最终用户在他们的浏览器里执行页面刷新操作就可以实现。 setAttribute()并不会修改文档的物理内容，而是改变DOM树。这是因为浏览器实际显示的是DOM树的内容，在浏览器看来，DOM节点树才是文档 注意事项 getElementById()返回的是一个具有指定ID属性值的元素节点对应的对象，是一个单一对象，因此getElementById中元素Element为单数。 getElementsByTagName()和getElementsByClassName()方法返回的是对象数组，因此，Elements为复数。 getElementsByTagName()The getElementsByTagName() method returns a collection of an elements’s child elements with the specified tag name, as a NodeList object. The NodeList object represents a collection of nodes. The nodes can be accessed by index numbers. The index starts at 0. Tip: You can use the length property of the NodeList object to determine the number of child nodes with the specified tag name, then you can loop through all nodes and extract the info you want. Tip: The parametervalue “*” returns all of the element’s child elements.— W3 School 若HTML文档为1&lt;div class="demo" id="demo"&gt;Hello World&lt;/div&gt; 考虑如下代码1123// code 1var demo = document.getElementById("demo");demo.setAttribute("class", "democlass"); 上述代码1可以成功地将&lt;div&gt;的class属性值设置为democlass。这是因为getElementById()返回的是一个具有指定ID属性值的元素节点对应的对象，是一个单一对象。此时，demo为&lt;div class=&quot;demo&quot; id=&quot;demo&quot;&gt;Hello World&lt;/div&gt;。 若要用getElementsByTagName()和getElementsByClassName()方法实现上述同样的功能，需要避免如下错误，如下代码2所示。1234// code 2var demo = document.getElementsByClassName("demo");console.log(demo);demo.setAttribute("class", "democlass"); 执行上述代码2，会出现如下错误。错误原因是因为getElementsByClassName()方法返回的是对象数组，而不是一个单一的对象，即使HTML中只有一个class=&quot;demo&quot;的元素。控制台输出demo结果为[div#demo.demo, demo: div#demo.demo]，如下图所示。demo是一个对象数组，demo[0]才是&lt;div class=&quot;demo&quot; id=&quot;demo&quot;&gt;Hello World&lt;/div&gt;。 对于上述代码，进行如下修改，则可以正常修改&lt;div&gt;的class名。1234// code 2var demo0 = document.getElementsByClassName("demo")[0];console.log(demo0);demo0.setAttribute("class", "democlass"); 上述代码运行结果为 类似地，若采用getElementsByTagName()实现上述功能，仍然要注意该方法返回的是一个对象数组，而不是一个对象。12345// code 3var demo = document.getElementsByTagName("demo"); //对象数组var demo0 = demo[0]; //一个对象demo0.setAttribute("class", "democlass"); //正常demo.setAttribute("class", "democlass"); //TypeError 改变元素属性的DOM解决方案和非DOM解决方案以改变&lt;img&gt;标签的src属性为例，提供DOM解决方案和非DOM解决方案。（下例代码中whicpic为点击的&lt;a&gt;标签，将&lt;a&gt;标签的href属性值传递给&lt;img&gt;标签的src属性）1234//DOM 解决方案var source = whichpic.getAttribute("href");//获取a标签的href属性 var placeholder = document.getElementById("placeholder"); //获取img对象 placeholder.setAttribute("src",source); //属性设置 DOM解决方案中，通过getAttribute和setAttribute来进行属性的设置。而非DOM方案中，直接对属性值进行设置即可。1placeholder.src = source; 个人更推荐DOM解决方案，因为DOM方案的调用格式都相同，非DOM方案中每种属性值设置方法不一样，需要去识记。此外，DOM方案对于任何一种标记语言都适用，而非DOM方案则不具有普适性。 ###3.7 标签中阻止点击默认行为的发生123456789&lt;ul&gt; &lt;li&gt; &lt;a href="images/fireworks.jpg" title="A fireworks display" onclick="showPic(this); return false;"&gt;Fireworks&lt;/a&gt; &lt;/li&gt; &lt;li&gt; &lt;a href="images/coffee.jpg" title="A cup of black coffee" onclick="showPic(this); return false;"&gt;Coffee&lt;/a&gt; &lt;/li&gt;&lt;/ul&gt; 对于上述代码，点击对应的&lt;a&gt;标签，会调用对应的事件处理函数showPic(this)。如果不加上return false或者return true，则会执行&lt;a&gt;标签被点击后的默认行为（此处为在一个新的窗口中显示图片）。为了阻止默认行为的发生，可以对onclick事件给出一个返回值：return true表示这个链接已经被点击了，则会执行默认的行为；return false表示这个链接没有被点击，则不会触发默认的行为。 ###3.8 其他 childNodes在一棵节点树上，childNodes属性可以用来获取任何一个元素的所有子元素，它是一个包含这个元素全部子元素的数组。1element.childNodes 例如，获取body元素的全部子元素，其方法为123var body_elemengt = document.getElementsByTagName(&quot;body&quot;)[0]; //[0] 不要忘记body_element.childNodes; //子元素body_element.childNodes.length; //返回子元素个数 nodeTypenode.nodeType可以获取节点的节点属性，其返回值是一个数字，共12种取值，最常用的返回值有3种。（1）元素节点的nodeType属性值 = 1（2）属性节点的nodeType属性值 = 2（3）文本节点的nodeType属性值 = 3 例如，对于1&lt;p title="a gentle reminder"&gt; Don't forget to buy this stuff.&lt;/p&gt; ，其元素节点为p，其属性节点为title=&quot;a gentle reminder&quot;，其文本节点为Don&#39;t forget to buy this stuff.。 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="demo" id="demo"&gt;Hello World&lt;/div&gt; &lt;script&gt; console.log(document.getElementsByTagName("body")[0].childNodes.length); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 执行上述代码，控制台输出body的子元素个数为4：1个元素节点div，1个属性节点(id和class属性值算作一个节点)，1个文本节点，1个元素节点&lt;script&gt;。即element.childNodes.length会统计所有种类的节点个数，而不仅仅是元素节点个数。若想统计元素节点个数，可以根据nodeType值进行判断。123456789var myChildNodes = document.getElementsByTagName("body")[0].childNodes;var length = myChildNodes.length;var count = 0;for(var i=0;i&lt;length;i++)&#123; if(myChildNodes[i].nodeType == 1) &#123; count++; &#125;&#125;console.log(count); //2 1个元素节点div 1个元素节点`&lt;script&gt;` nodeValue The nodeValue property sets or returns the node value of the specified node. If the node is an element node, the nodeValue property will return null.Note: If you want to return the text of an element, remember that text is always inside a Text node, and you will have to return the Text node’s node value (element.childNodes[0].nodeValue). — W3 School HTML DOM nodeValue Property 1&lt;p id=&quot;description&quot;&gt;Choose an image&lt;/p&gt; 对于上述节点，执行如下代码。123var description = document.getElementById("description");alert(description.nodeValue); //nullalert(description.childNodes[0].nodeValue); //Choose an image 元素节点的nodeValue值是null。因此，description.nodeValue的值为null。若要返回元素节点中的文本，需要执行element.childNodes[0].nodeValue语句。 firstChild， lastChild 12element.childNodes[0] = element.firstChild;element.childNodes[element.childNodes.length-1] = element.lastChild; nodeNameGo to W3 School website for more information. nodeName可以返回节点的名称，注意返回的字符串都是大写的。12document.getElementsByTagName("div").nodeName == "div"; //falsedocument.getElementsByTagName("div").nodeName == "DIV"; //true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[三种方法实现瀑布流布局]]></title>
      <url>%2F2016%2F09%2F30%2F%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%E5%B8%83%E5%B1%80%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要总结了运用原生javascript、jquery和css3这三种方法实来现经典的瀑布流布局。 瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。 js实现通用函数的创建 12345678910function getClassObj(parent,className)&#123; var obj=parent.getElementsByTagName('*'); var pinS=[]; for (var i=0;i&lt;obj.length;i++) &#123; if (obj[i].className==className)&#123; pinS.push(obj[i]); &#125; &#125;; return pinS;&#125; 这个函数通过传入的父节点和类名称实现dom元素的获取，因为我们知道在原生js中没有可以通过类名称直接获取dom元素的函数，所以创建这样一个函数还是很方便的。实现方法：通过父节点的getElementsByTagName(&#39;*&#39;)方法获取下面所有的dom元素，然后对他们进行遍历获取classname的值 ，当与传入的参数类的名称一致就push到数组中保存下来，最后再返回数组即可。 1234567function getminHIndex(arr,minH)&#123; for(var i in arr)&#123; if(arr[i]==minH)&#123; return i; &#125; &#125;&#125; 这个函数通过传入的数组和某个高度值这两个参数获取针对这个value值的key值，即数组的序号。实现也很简单，就是遍历数组，比较值与传入的参数值是否相同，再返回键值即可。 固定图片数量的瀑布流布局12345var oParent=document.getElementById(parent); var aPin=getClassObj(oParent,pin); var iPinW=aPin[0].offsetWidth; var num=Math.floor(document.documentElement.clientWidth/iPinW); oParent.style.cssText='width:'+iPinW*num+'px;ma rgin:0 auto;'; 这段代码主要是为了获取每一行排列的固定列数和将外层元素的宽度设置为固定值。实现方法是offsetWidth获取图片的宽度，然后将clientWidth得到的浏览器可视区域宽度除以图片的宽度再向上取整，即为每一行的列数。 1234567891011121314var pinHArr=[]; for(var i=0;i&lt;aPin.length;i++)&#123; var pinH=aPin[i].offsetHeight; if(i&lt;num)&#123; pinHArr[i]=pinH; &#125;else&#123; var minH=Math.min.apply(null,pinHArr); var minHIndex=getminHIndex(pinHArr,minH); aPin[i].style.position='absolute'; aPin[i].style.top=minH+'px'; aPin[i].style.left=aPin[minHIndex].offsetLeft+'px'; pinHArr[minHIndex]+=aPin[i].offsetHeight; &#125; &#125; 这段代码实现将后一张图片插入到前面所有图片中距离浏览器顶部最短的那张的下面的效果。主要实现方法是将每一列的尾部距离浏览器顶部距离放入数组中，然后选取最短的那个，获得高度值，作为下一张图片插入来的属性参数值，然后将插入进来的图片高度再加入进去，更新数组值即可。 判断是否滚动到尾部12345678function checkscrollside()&#123; var oParent=document.getElementById('main'); var aPin=getClassObj(oParent,'pin'); var lastPinH=aPin[aPin.length-1].offsetTop+Math.floor(aPin[aPin.length-1].offsetHeight/2); var scrollTop=document.documentElement.scrollTop||document.body.scrollTop; var documentH=document.documentElement.clientHeight; return (lastPinH&lt;scrollTop+documentH)?true:false;&#125; 这个函数的判断条件就是当scrollTop得到的滚动距离加上clientHeight得到的文档的页面高度大于最后一张图片的高度值的一半处距离顶部的高度的时候，就认为滚动条已到底部，返回true。这里需要注意的是，document.documentElement.scrollTop||document.body.scrollTop是兼容性写法，标准模式用前者检测，而混杂模式用后者检测。 动态添加图片的瀑布流效果123456789101112var oParent = document.getElementById('main'); for(var i=0;i&lt;dataInt.data.length;i++)&#123; var oPin=document.createElement('div'); oPin.className='pin'; oParent.appendChild(oPin); var oBox=document.createElement('div'); oBox.className='box'; oPin.appendChild(oBox); var oImg=document.createElement('img'); oImg.src='./images/'+dataInt.data[i].src; oBox.appendChild(oImg); &#125; 其实这就是一个动态创建元素节点、添加属性、加入文档节点结构中的过程，这里为了方便演示，是用数组来储存将要添加的元素，实际中可以利用服务器端后台处理来不断添加图片。 jquery实现jquery实现的整体思路与javascript是一致的，只不过jquery里面有很多集成的方法，可以是过程相对比较简单一些，而且对兼容性的处理也会相对方便一些。 12345678910111213141516171819202122var $aPin = $( "#main&gt;div" ); var iPinW = $aPin.eq( 0 ).width(); var num = Math.floor( $( window ).width() / iPinW ); $( "#main" ).css(&#123; 'width:' : iPinW * num, 'margin': '0 auto' &#125;); var pinHArr=[]; $aPin.each( function( index, value )&#123; var pinH = $aPin.eq( index ).height(); if( index &lt; num )&#123; pinHArr[ index ] = pinH; &#125;else&#123; var minH = Math.min.apply( null, pinHArr ); var minHIndex = $.inArray( minH, pinHArr ); $( value ).css(&#123; 'position': 'absolute', 'top': minH + 15, 'left': $aPin.eq( minHIndex ).position().left &#125;); pinHArr[ minHIndex ] += $aPin.eq( index ).height() + 15; &#125; 如这里提取jquery对象的选择器方法就非常多和简便，不需要像原生javascript那样先写通过类名称获得dom对象的方法。同时jquery中还支持连缀写法和隐式迭代。还有像这里的each方法的应用也使得循环过程变得简单些。 1234567function checkscrollside()&#123; var $aPin = $( "#main&gt;div" ); var lastPinH = $aPin.last().get(0).offsetTop + Math.floor($aPin.last().height()/2); var scrollTop = $( window ).scrollTop(); var documentH = $( document ).width(); return (lastPinH &lt; scrollTop + documentH ) ? true : false;&#125; 这里关于获取滚动距离的时候，也不需要考虑兼容性的问题，直接用scrollTop()函数得到即可。 12345$.each( dataInt.data, function( index, value )&#123; var $oPin = $('&lt;div&gt;').addClass('pin').appendTo( $( "#main" ) ); var $oBox = $('&lt;div&gt;').addClass('box').appendTo( $oPin ); $('&lt;img&gt;').attr('src','./images/' + $( value).attr( 'src') ).appendTo($oBox); &#125;); 关于动态添加元素就更显方便了，通过链式写法和自带的函数方法相比于javascript来说可以一步到位。 css3实现123456.container&#123; -webkit-column-width:160px; -moz-column-width:160px; -webkit-column-gap:5px; -moz-column-gap:5px;&#125; 直接用CSS3的column-width 属性将显示列的宽度固定，用column-gap属性固定好列的间距，这里需要考虑到对Firefox、Safari 和 Chrome 浏览器的兼容性问题。用css3实现瀑布流布局有以下几个特点： 不需要编码进行计算，而浏览器会自动计算，只需要设置列宽即可，这样会提高性能。 但列宽会随着浏览器窗口大小进行改变，用户体验不好。 图片排序是按照垂直顺序排列的，打乱了原有的图片顺序。 如果想达到滚动到底部图片自动加载的效果，还是需要借助javascript来实现。总结这篇博文主要总结了js、jquery和css3三种方法来实现常见的瀑布流布局，其中js实现性能较高，但相对较为复杂，jquery实现较为简单，但是需要引入库文件，会影响性能，css3实现起来最为简便，性能也很高，但是在功能的实现和用户体验上与前面两种还是有很大差距，所以综合来说，推荐使用原生的javascript方法来实现瀑布流布局。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学校网页实例练习总结]]></title>
      <url>%2F2016%2F09%2F27%2F%E5%AD%A6%E6%A0%A1%E7%BD%91%E9%A1%B5%E5%AE%9E%E4%BE%8B%E7%BB%83%E4%B9%A0%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[前言本篇博文主要记录和总结了我在练习制作学校网页demo过程中的一些心得和技巧。 心得与技巧html/css设置盒子模型中文字垂直居中方法我们在设置css样式时，经常需要在如div中填写很多文字，而且大部分时候为了美观，都需要使文字在包裹元素中垂直居中，如本demo中的导航条里面的文字一样，这时我们可以通过设置文字行高line-height与width相同即可，这是非常常用的一个小技巧。如下所示：123456789.title &#123; height: 35px; border-bottom: 2px solid #E8E8E8; font-size: 14px; font-family: "微软雅黑"; line-height: 35px; font-weight: bold; color: #786F66;&#125; 背景图片设置技巧设置背景图片，很多时候不是给个background-image属性再加上一个图片的url地址就可以了，我们需要较为详细了解一下css常用的background属性。 以一个例子说明常用的背景属性：1234body &#123; background: #00FF00 url(bgimage.gif) no-repeat fixed center; &#125; 按照顺序，这些简写属性分别代表background-color、background-image、background-repeat、background-attachment和background-position。值得说明的是，background-repeat是代表如何重复背景图片，即可以选择默认在水平和垂直方向上重复repeat，仅在水平方向上重复repeat-x，仅在垂直方向上重复repeat-Y和不重复no-repeat等。background-position规定背景图像的位置。background-attachment规定背景图像是否固定或者随着页面的其余部分滚动。具体关于background属性的详细介绍参看css background属性。 在这demo中也利用了这个属性设置了导航条的背景：1234.nav_left &#123; width: 10px; background: url(../images/nav_left.jpg) no-repeat;&#125; 搜索栏中的放大镜 小图标也是用这种方法设置的： 12345.search_text &#123; ... background: url(../images/search.jpg) no-repeat right center; ...&#125; 这里添加一个小技巧，为了使搜索框里面的字不超过搜索小图标，可以给搜索框设置右填充，即内边距即可。 同理，还可以利用这种方法设置项目符号，如此demo中最新动态下面的项目符号，用背景图片的方式，并设置左内边距即可： 123456789.news_list li &#123; background: url(../images/list.jpg) no-repeat; list-style-type: none; padding-left: 10px; margin: 8px; border-bottom: 1px dotted #CCC; height: 17px; line-height: 17px;&#125; 如果设置list-style-image属性也可以达到类似的效果。 设置图片和文字对齐有时候在行间文字后面添加一个小图片的时候，如果不加任何设置，我们会发现文字和图片是错行的，这时我们可以利用vertical-align属性设置图片和文字对齐，如下所示：1234.logo_right img &#123; vertical-align: middle; margin-right: 10px;&#125; 此demo中为了使联系电话文字与旁边电话小图标在同一水平线上对齐，利用这个属性设置为middle达到效果。 a标签伪类设置CSS 伪类用于向某些选择器添加特殊的效果。其中a标签常用的四种锚伪类如下所示：1234a:link &#123;color: #FF0000&#125; /* 未访问的链接 */a:visited &#123;color: #00FF00&#125; /* 已访问的链接 */a:hover &#123;color: #FF00FF&#125; /* 鼠标移动到链接上 */a:active &#123;color: #0000FF&#125; /* 选定的链接 */ 这里在设置的时候有个需要特别注意的地方，即在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，a:active 必须被置于 a:hover 之后，才是有效的。 本demo中，导航条的a标签样式设置为如下形式 ，也是非常常用的一种格式： 12345678910.nav_mid a:link, .nav_mid a:visited &#123; font-size: 16px; color: #FFF; text-decoration: none;&#125;.nav_mid a:hover, .nav_mid a:active &#123; font-size: 16px; color: #FF0; text-decoration: none;&#125; li标签中a和span标签错位问题在正常设置最新动态下面的每一条动态标题和时间的时候，对标题用a标签实现，对对应的时间用span标签实现，并设置 span标签右浮动，然后按照正常的顺序书写html结构，但是在ie浏览器下可能会出现标题和时间不对齐错位的情况，这时解决办法是将a和span标签在li标签中的书写顺序进行调换： 12345678&lt;div class="news_list"&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;2016-07-20&lt;/span&gt; &lt;a href="news.html"&gt;2016年研究生管理信息系统培训会举行&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;2016-08-04&lt;/span&gt;&lt;a href="news.html"&gt;九名交大学子远赴丹麦参加创新实践夏令营&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;2016-09-08&lt;/span&gt;&lt;a href="news.html"&gt;我校10名博士生赴瑞典荷兰参加SEEEP暑期学校&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;2016-10-17&lt;/span&gt;&lt;a href="news.html" title="aa"&gt;2016年国际研究生招生总结交流会​召开&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; 插入视频的方法可以利用html中的embed标签实现，本demo中采用的是优酷中的视频，在视频下方‘分享给朋友’处点击下拉键，可以看到html代码选项，直接复制并修改相应属性即可： 123&lt;p class="video_content"&gt; &lt;embed src='http://player.youku.com/player.php/sid/XNDA4MTkxNzM2/v.swf' allowFullScreen='true' quality='high' width='220' height='140' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt; &lt;/p&gt; 底部区域ul和li嵌套实现为了实现底部区域分类列项的形式，可以通过ul标签和li标签的嵌套方式实现，如下所示： 1234567891011121314151617&lt;div class="copyright_content"&gt; &lt;ul&gt; &lt;li&gt;报名申请 &lt;ul&gt; &lt;li&gt;硕士研究生&lt;/li&gt; ...... &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;管理信息系统 &lt;ul&gt; &lt;li&gt;学生、教师、导师&lt;/li&gt; ...... &lt;/ul&gt; &lt;/li&gt; ...... &lt;/ul&gt; &lt;/div&gt; 为了达到理想的效果，这里在设置css样式的时候有需要注意的地方，在给li标签设置左浮动的同时，还需要给它设置一个固定的宽度，大小即为总外层div大小除以分成的列数，这样的目的是使嵌套的子li部分因为宽度限制而按照列排列而不是行排列，设置如下所示： 12345678.copyright_content li &#123; list-style-type: none; float: left; width: 200px; text-align: center; background: url(../images/line.png) no-repeat right center; ......&#125; 同样，列与列之间的竖线也是通过前面所述的背景图片方式设置的。而文字的居中对齐应用text-align: center实现。 JS设置焦点图制作在这个demo中上部有一块很大的焦点图区域，可以实现图片的轮播，给网站增加动态元素，避免使界面显得过于单调。这里主要使用myFocus插件来实现这个功能。 首先进入myFocus网站下载插件文件，然后在html文件的头部引入这个js文件： 1&lt;script type="text/javascript" src="js/myfocus-2.0.1.min.js" charset="utf-8"&gt;&lt;/script&gt; 之后在html文件中需要放置焦点图的地方添加结构： 123456789101112&lt;div class="ad"&gt; &lt;div id="boxID"&gt; &lt;div class="loading"&gt;&lt;img src="images/loading.gif" alt="请稍候..." /&gt;&lt;/div&gt; &lt;div class="pic"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/ad2.jpg" thumb="" alt="" text="" /&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/ad3.jpg" thumb="" alt="" text="" /&gt;&lt;/a&gt;&lt;/li&gt; ...... &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 这里需要注意以下几个问题： 焦点图初始化的ID与图片列表最外层的ID一致，这里的ID设置为‘boxID’。 图片列表外面，包裹一个class为pic的div。 为了使显示效果更友好，可以添加loading图片，使得在加载时显示出等待载入的效果。同时为了使ad的溢出部分隐藏，可以使用overflow属性，并设置为hidden即可，如下所示： 12345.ad &#123; height: 320px; margin-top: 5px; overflow: hidden;&#125; 最后在html文件的头部区域，还需要对myFocus进行属性的相关配置： 123456789myFocus.set(&#123; id:'boxID',//焦点图盒子ID pattern:'mF_fancy',//风格应用的名称 time:3,//切换时间间隔(秒) trigger:'click',//触发切换模式:'click'(点击)/'mouseover'(悬停) width:1000,//设置图片区域宽度(像素) height:310,//设置图片区域高度(像素) txtHeight:'default'//文字层高度设置(像素),'default'为默认高度，0为隐藏&#125;); 更详细配置请参考myFocus教程。 心得补充与小技巧 设置min-height可以使里面填充的内容超过包裹div元素的时候可以自动撑开，这里需要注意的一点是如果还有外层div包裹，也要一并设置这个属性，防止内容继续超过更外一层的div。(此属性ie6不支持，为了兼容，需要hack，即添加_height属性) 在设置间距的时候，得根据实际情况选择是使用margin还是padding来达到效果。如果其他条件相同，在可能会影响外界整体布局的情况下，推荐使用padding。 如果想设置a标签效果为鼠标放上去的时候的背景颜色变化是整个区域而不仅仅是字的颜色，则可以把display属性设置为block。同时考虑到兼容性问题，a标签高度在不同浏览器可能不一样，尤其背景填充的时候，这时可以考虑把它设置为内联块状元素来解决问题。 有时为了想达到包含文字的div的宽度大小是随着文字多少而不同的效果，这时可以只设置border而不设置宽度width即可，宽度通过内填充来撑开。总结在制作这个实例的过程中，虽然简单，但是可以锻炼关于基本html/css和div布局的基础，同时关注很多的细节处理，就能在实际的案例中可以学到很多小技巧和经验，积少成多，为以后打下基础。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Github+Hexo搭建独立域名的静态博客]]></title>
      <url>%2F2016%2F09%2F20%2FGithub%2BHexo%E6%90%AD%E5%BB%BA%E7%8B%AC%E7%AB%8B%E5%9F%9F%E5%90%8D%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[1. 前言查阅了很多资料，踩了很多的坑之后，一个拥有独立域名的静态博客终于搭建完成。本文主要叙述了利用github和hexo搭建博客的过程和心得，一方面希望给同样想搭建独立域名的静态博客的朋友一些启发与引导，另一方面也是给自己的个人笔记，记录下来以后不会遗忘。本文主要针对windows用户。 2. Github和Hexo介绍GitHub 是现在非常火热的一个面向开源及私有软件项目的托管平台，这里我们使用github pages服务搭建博客，使用这个服务的优势在于全是静态文件，访问速度很快，而且免费方便，不需要自己管理服务器和后台，可以将精力都放在博文的撰写上，同时还可以绑定自己的个人域名等。具体参考github官方网站。 Hexo是一款基于Node.js的静态博客框架，它的优势主要在于简便和快速，它支持多进程，支持GitHub Flavored Markdown和所有Octopress的插件，同时还拥有良好的扩展性，支持EJS、Swig和Stylus，并通过插件支持Haml、Jade和Less。具体参考hexo官方网站。 3. 搭建过程3.1 安装Git进入git官方网站下载并安装git，按照操作提示走就可以了。 3.2 安装Node.js进入node.js官方网站下载并安装node.js，步骤也很简单，按照提示走即可，这里需要注意的是，安装完之后最好将电脑重启一下。 3.3 安装和配置Hexo当电脑上成功安装了git和node.js之后，下面就可以通过命令行对hexo进行安装和配置。首先在任意地方点击鼠标右键，选择Git Bash这个选项，然后输入以下命令完成hexo的安装。1$ npm install hexo-cli -g 之后选择某个目录放置创建hexo的文件夹，如F:\hexo，然后进入此文件夹，点击鼠标右键，选择Git Bash这个选项，输入以下命令，实现hexo的初始化配置。12$ hexo init #hexo初始化$ npm install #安装依赖包 通过hexo -v命令可以查看安装的hexo的版本号，以此验证是否安装成功。这时继续在F:\hexo中执行以下命令：12$ hexo g #hexo generate 生成静态页面$ hexo s #hexo server 启动本地服务 在浏览器中打开http://localhost:4000，就可以看到hexo博客框架默认主题的效果了，在命令行中输入ctrl+c可以退出本地预览。 3.4 补充说明在生成静态页面和启动本地服务的时候如果出现报错信息：hexo:ERROR Deployer not found: git，则需要执行以下命令：1$ npm install hexo-deployer-git --save 而如果出现ERROR Plugin load failed: hexo-server的报错信息，则需要执行以下命令：1$ sudo npm install hexo-server 之后再按照上述命令启动本地服务即可看到默认主题的hexo页面了。 这里再补充介绍一下hexo的常用命令。12345678910111213hexo new "My New Post" # create a new posthexo server # run hexo serverhexo generate # Generate static fileshexo deploy # Deploy to remote siteshexo n #hexo new的简写hexo s # hexo server的简写hexo g # hexo generate的简写hexo d # hexo deploy的简写hexo clean # 清楚缓存文件hexo -v # 查看hexo版本hexo help # 查看hexo帮助hexo d -g # 生成部署 组合命令hexo s -g # 生成预览 组合命令 3.5 静态页面部署到Github上3.5.1 创建Github仓库现在我们还只能在本地查看，下面我们将我们的静态博客部署到github上。首先注册自己的github账号，记住自己的用户名、邮箱和密码等。然后在github的个人页面里，选择Repositories并点击New新建一个仓库repositories，填上仓库名Repository name，注意这里的仓库名必须是youname.github.io的形式，即你前面注册的用户名加上.github.io。建立完自己的仓库之后可以通过Settings里面的GitHub Page预览github提供的默认效果页面，网址就是https://youname.github.io/。 3.5.2 配置SSH如果github刚注册还未配置SSH，还需要先配置SSH。SSH 为 Secure Shell 的缩写，是建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。具体的配置方法参考史上最全github使用方法:github入门到精通 3.5.3 部署本地文件到Github上打开本地创建的hexo文件夹，找到_config.yml文件并打开它，这里推荐使用Sublime或Notepad++ 编辑器打开，进行如下修改：1234deploy: type: git repository: https://github.com/yourname/yourname.github.io.git branch: master 这里有两点需要注意，一个是这里的yourname还是前面说的改成注册github时的用户名，另一个是hexo的配置文件中任何’:’后面都是带一个空格的。修改之后保存，执行以下命令：123hexo clean hexo generate #or hexo ghexo deploy #or hexo d 之后打开https://yourname.github.io/看到静态博客页面，说明静态博客已成功部署到了github上。 3.6 修改Hexo配置文件在hexo中主要有两个非常重要的配置文件_config.yml，一个是站点配置文件，一个是主题配置文件。 3.6.1 站点配置文件首先来说一下站点配置文件的修改。站点配置文件位于hexo的根目录下，找到并打开它，主要需要修改的地方如下所示：123456title: Yinzhehao blog #博客名subtitle: Try my best #副标题description: 饮水思源 止于至善 #用于搜索author: Yin Zhehao #作者language: zh-Hans #语言timezone: #时区 12per_page: 10 #每页显示的文章数，0表示不分页pagination_dir: page 123plugins:- hexo-generator-feedtheme: next #使用的主题，即：hexo根目录themes文件夹下的主题文件夹名 1234feed: #配置rss type: atom path: atom.xml limit: 20 以上是站点配置文件中常用的一些需要修改的地方，大家根据自己的意愿进行相应的修改即可。 3.6.2 主题配置文件hexo官方提供了很多主题供大家选择，参见hexo主题主题具体使用方法就是点击自己想要的主题，进入该主题在github中的Repository，然后用git命令将主题clone到本地hexo根目录中themes文件夹下，并将上面站点主题配置里的theme名字改为下载的主题的文件夹名即可。而主题配置文件就位于下载的主题的文件夹里面。 以本博客使用的next主题为例，此主题的github仓库地址是hexo-theme-next，clone下来解压到hexo根目录中themes文件夹下后，将站点主题配置里的theme名字改为next，然后参考Next使用文档完成详细的主题配置，包括主题设定、集成第三方服务、添加标签和分类页面等等。 3.7 发表文章为了检验上面的hexo配置效果，也为以后撰写博客做准备，我们先小试牛刀，发表一篇文章。首先，在hexo根目录下执行以下命令：1$ hexo new &quot;your-post-name&quot; #双引号中是生成的md文件名 然后在F:\hexo\source\_post中打开your-post-name.md文件，同理推荐采用Sublime或Notepad++ 编辑器，并使用Markdown语法进行博客的撰写，Markdown语法参考Markdown语法说明。基本结构如下所示：1234567---title: your-post-name #文章标题date: 2016-09-20 15:57:06 #发表日期tags: [github,hexo,blog] #文章标签categories: blog #文章分类---#下面是正文部分 这里有个小技巧，如果文章整体较长或者作者不想游客一开始就观看到全部内容，可以选择写一段内容简介后，加上&lt;!--more--&gt;，这样之前的内容会显示，而之后的内容会被隐藏，显示Read more或阅读全文，当游客点击之后就能看到全部内容。 之后使用如下命令进行本地预览：12hexo cleanhexo s -g 使用如下命令部署到github上：12hexo cleanhexo d -g 最后打开浏览器登上https://yourname.github.io/就可以看到自己漂亮的静态博客了。 3.8 独立域名配置现在虽然可以访问个人博客了，但是用的域名还是https://yourname.github.io/，为了可以使用独立域名访问自己的个人博客，还需要进行一些设置。 3.8.1 申请与购买域名我是在阿里云进行域名的申请与购买的，大家可以在阿里云或其他地方申请与购买域名，根据不同的后缀价格不同。 3.8.2 DNS解析拥有域名之后还需要进行DNS解析，这里推荐使用DNSPod进行解析，具体方法参考如何使用dnspod解析域名，其中，需要向你的DNS 配置中添加 3 条记录：@ | A | 192.30.252.153@ | A | 192.30.252.154www | CNAME | username.github.io.其中username就是你自己的github用户名。DNS解析需要一段时间，需要耐心等待一会儿。 这里有个需要注意的问题，如果你是在阿里云申请购买的域名，而在DNSPod进行解析的时候，需要回到阿里云，将个人基本信息里面的DNS服务器修改为如下值：f1g1ns1.dnspod.netf1g1ns2.dnspod.net否则无法解析成功。 3.8.3 配置CNAME文件在hexo的根目录的source文件夹里手动添加一个名为CNAME的文件，文件名必须大写且一模一样，打开这个文件，并写上你的域名，且只能包含一个顶级域名，之后保存。然后像前面一样进行本地预览和部署即可。这时在浏览器中输入你的个人域名也可以访问你的静态博客啦。 4. 总结至此，利用Github和Hexo已经搭建出具有独立域名的静态博客了，而且具有了博客的一些基本功能。大家在搭建过程中如果遇到什么问题，欢迎一起探讨解决，也欢迎大家能对本文中存在的问题和不足进行批评指正。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown插入图片的方法和技巧]]></title>
      <url>%2F2016%2F09%2F18%2FMarkdown%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有 很多人用它写博客。世界上最流行的博客平台WordPress和大型CMS如Joomla、Drupal都能很好的支持Markdown,完全采用Markdown编辑器的博客平台有Ghost和Typecho。本人在自学过程中，感受到了Markdown的简洁性和广泛的应用，同时在实际应用中需要插入图片的地方几乎无处不在，为了使初学者可以更快找到适合自己的方法，本文对Markdown插入图片的方法和技巧进行了总结。 Markdown插入图片的方法方法一 行内式插入图片行内式语法结构：![Alt text](/path/to/img.png)或![Alt text](/path/to/img.png &quot;Optional title&quot;) 说明：Alt text中填写的是如果图片显示不出来时显示的文字；/path/to/img.png为图片所在的路径，可以是本地图片路径，也可以是网上图片路径；Optional title中填写的是你将鼠标放到图片上之后浮现出来的小框中的内容，是可选的。 方法二 参考式插入图片参考式语法结构：![Alt text][id] 说明：Alt text中填写的是如果图片显示不出来时显示的文字；id是图片参考的名称，而且此id需要预先定义。 id预先定义:[id]: url/to/image &quot;Optional title attribute&quot; 说明：/path/to/img.png为图片所在的路径，可以是本地图片路径，也可以是网上图片路径；Optional title中填写的是你将鼠标放到图片上之后浮现出来的小框中的内容，是可选的。 方法一和方法二本质上是相同的，只是语法的顺序和写法有些区别，但是都不支持更改图片的大小。 方法三 &lt;image&gt;标签插入图片 &lt;image&gt;标签格式写法：&lt;img src=&quot;/path/to/img.png&quot; width = &quot;宽度&quot; height = &quot;高度&quot; alt=&quot;图片名称&quot; /&gt; 说明：/path/to/img.png为图片所在的路径，可以是本地图片路径，也可以是网上图片路径；width后面填的是希望设置的图片宽度；height后面填的是希望设置的图片高度；alt后面填写的是图片的名称。 方法三是直接利用html的 &lt;image&gt;标签来插入图片，它最大的优势在于可以指定图片的大小。 Markdown插入图片的技巧技巧一 使用Mou编辑器来更改图片大小要想改变图片的大小，除了用上面方法三的方法之外，还可以利用Mou编辑器达到目的。语法结构如下：![Alt text](/path/to/img.png =width*height)其实总体语法结构是与方法一相似的，就是后面加上了=width*height,这里就写上所想要设置的宽度和高度即可。这里需要注意的是=前面还有一个空格，不要漏掉。 技巧二 使图片居中显示方法很简单，利用html标签中的&lt;div&gt;即可做到。具体操作是在外面包围div标签并设置align属性为center即可:123&lt;div align="center"&gt; ...&lt;/div&gt; 技巧三 用网址路径插入图片用本地路径有时会出现各种各样的问题，而如果用网址路径相对而言就不会出错，这里主要推荐两种方法： a、首先找一个类似于CloudApp、Droplr的网络分享软件，然后把图片放进去，生成一个网址，最后把这个网址复制到markdown前面方法中提到的/path/to/img.png中即可。 b、通过github储存图片来达到目的。首先将需要的照片放到本地的git仓库中，并提交和发布到github上面，然后访问自己的github，找到那张图片，打开图片，选择Raw按钮，这时你会看到一个页面只有那张图片，这时将此链接地址复制下来，最后把这个网址复制到markdown前面方法中提到的/path/to/img.png中即可。 参考资料 1. 一分钟学会Markdown语法 2. Markdown 语法说明]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[中秋，继续前行]]></title>
      <url>%2F2016%2F09%2F15%2F%E4%B8%AD%E7%A7%8B%E6%80%9D%E4%B9%A1%2F</url>
      <content type="text"><![CDATA[2016年9月15日，是中秋节，也是我拥有自己第一个独立域名博客的日子。以前虽说也有记录和总结自己学习过程的心得成果的习惯，不过还是第一次可以在自己独立域名的博客上写博文，后面我也将抽空逐渐将以前的很多学习笔记和总结等整理到这个博客中来，同时自己也将继续不断地学习和充实自己，中秋，继续前行！兴奋之余，本想叙述一下创建这个独立博客过程中的种种艰辛以及记录创建博客的方法心得，却不知为何，心中涌出一股惆怅，哦，想家了。 明月几时有？把酒问青天。不知天上宫阙，今夕是何年？我欲乘风归去，又恐琼楼玉宇，高处不胜寒！起舞弄清影，何似在人间？转朱阁，低绮户，照无眠。不应有恨，何事长向别时圆？人有悲欢离合，月有阴晴圆缺，此事古难全。但愿人长久，千里共婵娟。————《水调歌头》 耳边响起这首熟悉的歌曲，想起自己作为在外求学的游子，今年又不能回去和父母团圆，能做的也只是打一个电话，道一句问候，报一声平安。不觉想起那些年故乡的明月，月色如水，天地一清，家人团聚，一切都是那么的温馨美好。或许就像某人说得那样：再也没有那么好吃的月饼了，再也没有那么纯净的明月了。 海内存知己，天涯若比邻。愿天下有情人，终成眷属。愿天下的父母，身体健康。祝天下芸芸众生，中秋快乐！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F09%2F15%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
